echo package -Dmaven.test.skip=True
package -Dmaven.test.skip=True
echo 'java ${java_d_options} -cp ./target/snr-server-0.0.1-SNAPSHOT.jar:lib/*:target/lib/* org.javelus.snr.toy.CompareBindingAnalysisAndEclipseJDT "${snr_snippets_folder}" "${snr_library_external}" true false' | ./benchmark/set_env.bash
Processing snippet: /iJTyper/Baseline/SnR/benchmark/../src/test/resources/snippets/so/Class_16.java
Expect check=1474
Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Did not find solution for node: Class_16 with type Type1
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: HKEY_CURRENT_USER=0x80000001
Did not find solution for node: HKEY_CURRENT_USER=0x80000001 with type Type9
Did not find solution for node: HKEY_CURRENT_USER with type Type9
Did not find solution for node: 0x80000001 with type Type84
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: HKEY_LOCAL_MACHINE=0x80000002
Did not find solution for node: HKEY_LOCAL_MACHINE=0x80000002 with type Type9
Did not find solution for node: HKEY_LOCAL_MACHINE with type Type9
Did not find solution for node: 0x80000002 with type Type84
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: REG_SUCCESS=0
Did not find solution for node: REG_SUCCESS=0 with type Type9
Did not find solution for node: REG_SUCCESS with type Type9
Did not find solution for node: 0 with type Type7
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: REG_NOTFOUND=2
Did not find solution for node: REG_NOTFOUND=2 with type Type9
Did not find solution for node: REG_NOTFOUND with type Type9
Did not find solution for node: 2 with type Type7
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: REG_ACCESSDENIED=5
Did not find solution for node: REG_ACCESSDENIED=5 with type Type9
Did not find solution for node: REG_ACCESSDENIED with type Type9
Did not find solution for node: 5 with type Type7
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: KEY_ALL_ACCESS=0xf003f
Did not find solution for node: KEY_ALL_ACCESS=0xf003f with type Type9
Did not find solution for node: KEY_ALL_ACCESS with type Type9
Did not find solution for node: 0xf003f with type Type85
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: KEY_READ=0x20019
Did not find solution for node: KEY_READ=0x20019 with type Type9
Did not find solution for node: KEY_READ with type Type9
Did not find solution for node: 0x20019 with type Type9
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: userRoot=Preferences.userRoot()
For node: userRoot=Preferences.userRoot() expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: userRoot expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences.userRoot() expected fqn: java.util.prefs.Preferences with type: Type86 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: userRoot
For node: userRoot expected fqn: java.util.prefs.Preferences with type: Type86 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: systemRoot=Preferences.systemRoot()
For node: systemRoot=Preferences.systemRoot() expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: systemRoot expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences.systemRoot() expected fqn: java.util.prefs.Preferences with type: Type88 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: systemRoot
For node: systemRoot expected fqn: java.util.prefs.Preferences with type: Type88 got: java.util.prefs.Preferences
Did not find solution for node: Class<? extends Preferences> with type Type82=Type80<Type81>
Did not find solution for node: Class with type Type80
Did not find solution for node: Class with type Type80
For node: ? extends Preferences expected fqn: ? extends java.util.prefs.Preferences with type: Type81 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: userClass=userRoot.getClass()
Did not find solution for node: userClass=userRoot.getClass() with type Type82=Type80<Type81>
Did not find solution for node: userClass with type Type82=Type80<Type81>
Did not find solution for node: userRoot.getClass() with type Type90
For node: userRoot expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: getClass
Did not find solution for node: getClass with type Type90
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regOpenKey
For node: regOpenKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regOpenKey
Cannot find matching typeVariable for: private static final Method regOpenKey;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regCloseKey
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regCloseKey
Cannot find matching typeVariable for: private static final Method regCloseKey;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regQueryValueEx
For node: regQueryValueEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regQueryValueEx
Cannot find matching typeVariable for: private static final Method regQueryValueEx;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regEnumValue
For node: regEnumValue expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regEnumValue
Cannot find matching typeVariable for: private static final Method regEnumValue;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regQueryInfoKey
For node: regQueryInfoKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regQueryInfoKey
Cannot find matching typeVariable for: private static final Method regQueryInfoKey;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regEnumKeyEx
For node: regEnumKeyEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regEnumKeyEx
Cannot find matching typeVariable for: private static final Method regEnumKeyEx;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regCreateKeyEx
For node: regCreateKeyEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regCreateKeyEx
Cannot find matching typeVariable for: private static final Method regCreateKeyEx;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regSetValueEx
For node: regSetValueEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regSetValueEx
Cannot find matching typeVariable for: private static final Method regSetValueEx;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regDeleteKey
For node: regDeleteKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regDeleteKey
Cannot find matching typeVariable for: private static final Method regDeleteKey;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: Method expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regDeleteValue
For node: regDeleteValue expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: regDeleteValue
Cannot find matching typeVariable for: private static final Method regDeleteValue;

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regOpenKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class}) expected fqn: java.lang.reflect.Method with type: Type97 got: java.lang.reflect.Method
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
For node: getDeclaredMethod expected fqn: java.lang.reflect.Method with type: Type97 got: java.lang.reflect.Method
Did not find solution for node: "WindowsRegOpenKey" with type Type92
Did not find solution for node: new Class[]{int.class,byte[].class,int.class} with type Type93
Did not find solution for node: Class[] with type Type93
Did not find solution for node: Class with type Type80
Did not find solution for node: Class with type Type80
Did not find solution for node: {int.class,byte[].class,int.class} with type Type95
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: byte[].class expected fqn: java.lang.Class<byte[]> with type: Type94 got: java.lang.Class
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: regOpenKey.setAccessible(true) expected fqn: void with type: Type106 got: void
For node: regOpenKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type106 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
For node: regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Did not find solution for node: userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class}) with type Type104
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
Did not find solution for node: getDeclaredMethod with type Type104
Did not find solution for node: "WindowsRegCloseKey" with type Type92
Did not find solution for node: new Class[]{int.class} with type Type93
Did not find solution for node: Class[] with type Type93
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
Did not find solution for node: {int.class} with type Type109
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: regCloseKey.setAccessible(true) expected fqn: void with type: Type108 got: void
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type108 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
For node: regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regQueryValueEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Did not find solution for node: userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class}) with type Type104
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
Did not find solution for node: getDeclaredMethod with type Type104
Did not find solution for node: "WindowsRegQueryValueEx" with type Type92
Did not find solution for node: new Class[]{int.class,byte[].class} with type Type93
Did not find solution for node: Class[] with type Type93
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
Did not find solution for node: {int.class,byte[].class} with type Type111
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: byte[].class expected fqn: java.lang.Class<byte[]> with type: Type94 got: java.lang.Class
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
For node: regQueryValueEx.setAccessible(true) expected fqn: void with type: Type108 got: void
For node: regQueryValueEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type108 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
For node: regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regEnumValue expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Did not find solution for node: userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class}) with type Type104
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
Did not find solution for node: getDeclaredMethod with type Type104
Did not find solution for node: "WindowsRegEnumValue" with type Type92
Did not find solution for node: new Class[]{int.class,int.class,int.class} with type Type93
Did not find solution for node: Class[] with type Type93
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
Did not find solution for node: {int.class,int.class,int.class} with type Type113
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: regEnumValue.setAccessible(true) expected fqn: void with type: Type108 got: void
For node: regEnumValue expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type108 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
For node: regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regQueryInfoKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Did not find solution for node: userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class}) with type Type104
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
Did not find solution for node: getDeclaredMethod with type Type104
Did not find solution for node: "WindowsRegQueryInfoKey1" with type Type92
Did not find solution for node: new Class[]{int.class} with type Type93
Did not find solution for node: Class[] with type Type93
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
Did not find solution for node: {int.class} with type Type115
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: regQueryInfoKey.setAccessible(true) expected fqn: void with type: Type108 got: void
For node: regQueryInfoKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type108 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
For node: regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regEnumKeyEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Did not find solution for node: userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class}) with type Type104
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
Did not find solution for node: getDeclaredMethod with type Type104
Did not find solution for node: "WindowsRegEnumKeyEx" with type Type92
Did not find solution for node: new Class[]{int.class,int.class,int.class} with type Type93
Did not find solution for node: Class[] with type Type93
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
Did not find solution for node: {int.class,int.class,int.class} with type Type117
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: regEnumKeyEx.setAccessible(true) expected fqn: void with type: Type108 got: void
For node: regEnumKeyEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type108 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
For node: regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regCreateKeyEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Did not find solution for node: userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class}) with type Type104
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
Did not find solution for node: getDeclaredMethod with type Type104
Did not find solution for node: "WindowsRegCreateKeyEx" with type Type92
Did not find solution for node: new Class[]{int.class,byte[].class} with type Type93
Did not find solution for node: Class[] with type Type93
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
Did not find solution for node: {int.class,byte[].class} with type Type119
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: byte[].class expected fqn: java.lang.Class<byte[]> with type: Type94 got: java.lang.Class
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
For node: regCreateKeyEx.setAccessible(true) expected fqn: void with type: Type108 got: void
For node: regCreateKeyEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type108 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
For node: regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regSetValueEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Did not find solution for node: userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class}) with type Type104
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
Did not find solution for node: getDeclaredMethod with type Type104
Did not find solution for node: "WindowsRegSetValueEx" with type Type92
Did not find solution for node: new Class[]{int.class,byte[].class,byte[].class} with type Type93
Did not find solution for node: Class[] with type Type93
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
Did not find solution for node: {int.class,byte[].class,byte[].class} with type Type121
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: byte[].class expected fqn: java.lang.Class<byte[]> with type: Type94 got: java.lang.Class
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
For node: byte[].class expected fqn: java.lang.Class<byte[]> with type: Type94 got: java.lang.Class
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
For node: regSetValueEx.setAccessible(true) expected fqn: void with type: Type108 got: void
For node: regSetValueEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type108 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
For node: regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regDeleteValue expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Did not find solution for node: userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class}) with type Type104
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
Did not find solution for node: getDeclaredMethod with type Type104
Did not find solution for node: "WindowsRegDeleteValue" with type Type92
Did not find solution for node: new Class[]{int.class,byte[].class} with type Type93
Did not find solution for node: Class[] with type Type93
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
Did not find solution for node: {int.class,byte[].class} with type Type123
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: byte[].class expected fqn: java.lang.Class<byte[]> with type: Type94 got: java.lang.Class
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
For node: regDeleteValue.setAccessible(true) expected fqn: void with type: Type108 got: void
For node: regDeleteValue expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type108 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
For node: regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class}) expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
For node: regDeleteKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Did not find solution for node: userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class}) with type Type104
Did not find solution for node: userClass with type Type82=Type80<Type81>
Cannot find matching typeVariable for: getDeclaredMethod
Did not find solution for node: getDeclaredMethod with type Type104
Did not find solution for node: "WindowsRegDeleteKey" with type Type92
Did not find solution for node: new Class[]{int.class,byte[].class} with type Type93
Did not find solution for node: Class[] with type Type93
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
For node: Class expected fqn: java.lang.Class with type: Type94 got: java.lang.Class
Did not find solution for node: {int.class,byte[].class} with type Type125
For node: int.class expected fqn: java.lang.Class<java.lang.Integer> with type: Type94 got: java.lang.Class
Did not find solution for node: int with type Type9
For node: byte[].class expected fqn: java.lang.Class<byte[]> with type: Type94 got: java.lang.Class
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
For node: regDeleteKey.setAccessible(true) expected fqn: void with type: Type108 got: void
For node: regDeleteKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: setAccessible
For node: setAccessible expected fqn: void with type: Type108 got: void
For node: true expected fqn: boolean with type: Type105 got: boolean
Cannot find matching typeVariable for: Exception e
For node: Exception e expected fqn: java.lang.Exception with type: Type127 got: java.lang.Exception
For node: Exception expected fqn: java.lang.Exception with type: Type127 got: java.lang.Exception
For node: Exception expected fqn: java.lang.Exception with type: Type127 got: java.lang.Exception
For node: e expected fqn: java.lang.Exception with type: Type127 got: java.lang.Exception
For node: new RuntimeException(e) expected fqn: java.lang.RuntimeException with type: Type128 got: java.lang.RuntimeException
For node: RuntimeException expected fqn: java.lang.RuntimeException with type: Type128 got: java.lang.RuntimeException
For node: RuntimeException expected fqn: java.lang.RuntimeException with type: Type128 got: java.lang.RuntimeException
For node: e expected fqn: java.lang.Exception with type: Type127 got: java.lang.Exception
Cannot find matching typeVariable for: Class_16
Cannot find matching typeVariable for: private Class_16(){
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Cannot find matching typeVariable for: readString
Cannot find matching typeVariable for: /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
public static String readString(int hkey,String key,String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  if (hkey == HKEY_LOCAL_MACHINE) {
    return readString(systemRoot,hkey,key,valueName);
  }
 else   if (hkey == HKEY_CURRENT_USER) {
    return readString(userRoot,hkey,key,valueName);
  }
 else {
    throw new IllegalArgumentException("hkey=" + hkey);
  }
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Cannot find matching typeVariable for: String valueName
Did not find solution for node: String valueName with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: valueName with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: hkey == HKEY_LOCAL_MACHINE expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_LOCAL_MACHINE with type Type9
For node: readString(systemRoot,hkey,key,valueName) expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: readString
For node: readString expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: systemRoot
For node: systemRoot expected fqn: java.util.prefs.Preferences with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: hkey
For node: hkey expected fqn: int with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: key
For node: key expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: valueName
For node: valueName expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: hkey == HKEY_CURRENT_USER expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_CURRENT_USER with type Type9
For node: readString(userRoot,hkey,key,valueName) expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: readString
For node: readString expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: userRoot
For node: userRoot expected fqn: java.util.prefs.Preferences with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: hkey
For node: hkey expected fqn: int with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: key
For node: key expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: valueName
For node: valueName expected fqn: java.lang.String with type: Type3 got: java.lang.String
Did not find solution for node: new IllegalArgumentException("hkey=" + hkey) with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: "hkey=" + hkey with type Type92
Did not find solution for node: "hkey=" with type Type92
Did not find solution for node: hkey with type Type9
Did not find solution for node: Map<String,String> with type Type136=Type2<Type92,Type92>
For node: Map expected fqn: java.util.Map<java.lang.String,java.lang.String> with type: Type2 got: java.util.Map
For node: Map expected fqn: java.util.Map<java.lang.String,java.lang.String> with type: Type2 got: java.util.Map
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Cannot find matching typeVariable for: readStringValues
Cannot find matching typeVariable for: /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
public static Map<String,String> readStringValues(int hkey,String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  if (hkey == HKEY_LOCAL_MACHINE) {
    return readStringValues(systemRoot,hkey,key);
  }
 else   if (hkey == HKEY_CURRENT_USER) {
    return readStringValues(userRoot,hkey,key);
  }
 else {
    throw new IllegalArgumentException("hkey=" + hkey);
  }
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: hkey == HKEY_LOCAL_MACHINE expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_LOCAL_MACHINE with type Type9
Did not find solution for node: readStringValues(systemRoot,hkey,key) with type Type4=Type2<Type3,Type3>
Cannot find matching typeVariable for: readStringValues
Did not find solution for node: readStringValues with type Type4=Type2<Type3,Type3>
Cannot find matching typeVariable for: systemRoot
Did not find solution for node: systemRoot with type Type4=Type2<Type3,Type3>
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type4=Type2<Type3,Type3>
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type4=Type2<Type3,Type3>
For node: hkey == HKEY_CURRENT_USER expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_CURRENT_USER with type Type9
Did not find solution for node: readStringValues(userRoot,hkey,key) with type Type4=Type2<Type3,Type3>
Cannot find matching typeVariable for: readStringValues
Did not find solution for node: readStringValues with type Type4=Type2<Type3,Type3>
Cannot find matching typeVariable for: userRoot
Did not find solution for node: userRoot with type Type4=Type2<Type3,Type3>
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type4=Type2<Type3,Type3>
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type4=Type2<Type3,Type3>
Did not find solution for node: new IllegalArgumentException("hkey=" + hkey) with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: "hkey=" + hkey with type Type92
Did not find solution for node: "hkey=" with type Type92
Did not find solution for node: hkey with type Type9
Did not find solution for node: List<String> with type Type137=Type5<Type92>
For node: List expected fqn: java.util.List<java.lang.String> with type: Type5 got: java.util.List
For node: List expected fqn: java.util.List<java.lang.String> with type: Type5 got: java.util.List
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Cannot find matching typeVariable for: readStringSubKeys
Cannot find matching typeVariable for: /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
public static List<String> readStringSubKeys(int hkey,String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  if (hkey == HKEY_LOCAL_MACHINE) {
    return readStringSubKeys(systemRoot,hkey,key);
  }
 else   if (hkey == HKEY_CURRENT_USER) {
    return readStringSubKeys(userRoot,hkey,key);
  }
 else {
    throw new IllegalArgumentException("hkey=" + hkey);
  }
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: hkey == HKEY_LOCAL_MACHINE expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_LOCAL_MACHINE with type Type9
Did not find solution for node: readStringSubKeys(systemRoot,hkey,key) with type Type6=Type5<Type3>
Cannot find matching typeVariable for: readStringSubKeys
Did not find solution for node: readStringSubKeys with type Type6=Type5<Type3>
Cannot find matching typeVariable for: systemRoot
Did not find solution for node: systemRoot with type Type6=Type5<Type3>
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type6=Type5<Type3>
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type6=Type5<Type3>
For node: hkey == HKEY_CURRENT_USER expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_CURRENT_USER with type Type9
Did not find solution for node: readStringSubKeys(userRoot,hkey,key) with type Type6=Type5<Type3>
Cannot find matching typeVariable for: readStringSubKeys
Did not find solution for node: readStringSubKeys with type Type6=Type5<Type3>
Cannot find matching typeVariable for: userRoot
Did not find solution for node: userRoot with type Type6=Type5<Type3>
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type6=Type5<Type3>
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type6=Type5<Type3>
Did not find solution for node: new IllegalArgumentException("hkey=" + hkey) with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: "hkey=" + hkey with type Type92
Did not find solution for node: "hkey=" with type Type92
Did not find solution for node: hkey with type Type9
For node: void expected fqn: void with type: Type12 got: void
Cannot find matching typeVariable for: createKey
Cannot find matching typeVariable for: /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
public static void createKey(int hkey,String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  int[] ret;
  if (hkey == HKEY_LOCAL_MACHINE) {
    ret=createKey(systemRoot,hkey,key);
    regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
  }
 else   if (hkey == HKEY_CURRENT_USER) {
    ret=createKey(userRoot,hkey,key);
    regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
  }
 else {
    throw new IllegalArgumentException("hkey=" + hkey);
  }
  if (ret[1] != REG_SUCCESS) {
    throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
  }
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: ret
Did not find solution for node: ret with type Type10
Cannot find matching typeVariable for: ret
Cannot find matching typeVariable for: int[] ret;

Cannot find matching typeVariable for: {
  int[] ret;
  if (hkey == HKEY_LOCAL_MACHINE) {
    ret=createKey(systemRoot,hkey,key);
    regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
  }
 else   if (hkey == HKEY_CURRENT_USER) {
    ret=createKey(userRoot,hkey,key);
    regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
  }
 else {
    throw new IllegalArgumentException("hkey=" + hkey);
  }
  if (ret[1] != REG_SUCCESS) {
    throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
  }
}

Cannot find matching typeVariable for: /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
public static void createKey(int hkey,String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  int[] ret;
  if (hkey == HKEY_LOCAL_MACHINE) {
    ret=createKey(systemRoot,hkey,key);
    regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
  }
 else   if (hkey == HKEY_CURRENT_USER) {
    ret=createKey(userRoot,hkey,key);
    regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
  }
 else {
    throw new IllegalArgumentException("hkey=" + hkey);
  }
  if (ret[1] != REG_SUCCESS) {
    throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
  }
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

For node: hkey == HKEY_LOCAL_MACHINE expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_LOCAL_MACHINE with type Type9
Did not find solution for node: ret=createKey(systemRoot,hkey,key) with type Type10
Did not find solution for node: ret with type Type10
Did not find solution for node: createKey(systemRoot,hkey,key) with type Type10
Cannot find matching typeVariable for: createKey
Did not find solution for node: createKey with type Type10
Cannot find matching typeVariable for: systemRoot
Did not find solution for node: systemRoot with type Type10
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type10
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type10
For node: regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])}) expected fqn: java.lang.Object with type: Type145 got: java.lang.Object
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
For node: invoke expected fqn: java.lang.Object with type: Type145 got: java.lang.Object
For node: systemRoot expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(ret[0])} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(ret[0])} with type Type143
Did not find solution for node: new Integer(ret[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: ret[0] with type Type9
Did not find solution for node: ret with type Type10
Did not find solution for node: 0 with type Type7
For node: hkey == HKEY_CURRENT_USER expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_CURRENT_USER with type Type9
Did not find solution for node: ret=createKey(userRoot,hkey,key) with type Type10
Did not find solution for node: ret with type Type10
Did not find solution for node: createKey(userRoot,hkey,key) with type Type10
Cannot find matching typeVariable for: createKey
Did not find solution for node: createKey with type Type10
Cannot find matching typeVariable for: userRoot
Did not find solution for node: userRoot with type Type10
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type10
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type10
Did not find solution for node: regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])}) with type Type148
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: userRoot expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(ret[0])} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(ret[0])} with type Type149
Did not find solution for node: new Integer(ret[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: ret[0] with type Type9
Did not find solution for node: ret with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: new IllegalArgumentException("hkey=" + hkey) with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: "hkey=" + hkey with type Type92
Did not find solution for node: "hkey=" with type Type92
Did not find solution for node: hkey with type Type9
For node: ret[1] != REG_SUCCESS expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: ret[1] with type Type9
Did not find solution for node: ret with type Type10
Did not find solution for node: 1 with type Type7
Did not find solution for node: REG_SUCCESS with type Type9
Did not find solution for node: new IllegalArgumentException("rc=" + ret[1] + "  key="+ key) with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: "rc=" + ret[1] + "  key="+ key with type Type92
Did not find solution for node: "rc=" with type Type92
Did not find solution for node: ret[1] with type Type9
Did not find solution for node: ret with type Type10
Did not find solution for node: 1 with type Type7
Did not find solution for node: "  key=" with type Type92
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type92
For node: void expected fqn: void with type: Type12 got: void
Cannot find matching typeVariable for: writeStringValue
Cannot find matching typeVariable for: /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
public static void writeStringValue(int hkey,String key,String valueName,String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  if (hkey == HKEY_LOCAL_MACHINE) {
    writeStringValue(systemRoot,hkey,key,valueName,value);
  }
 else   if (hkey == HKEY_CURRENT_USER) {
    writeStringValue(userRoot,hkey,key,valueName,value);
  }
 else {
    throw new IllegalArgumentException("hkey=" + hkey);
  }
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Cannot find matching typeVariable for: String valueName
Did not find solution for node: String valueName with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: valueName with type Type92
Cannot find matching typeVariable for: String value
Did not find solution for node: String value with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: value with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: hkey == HKEY_LOCAL_MACHINE expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_LOCAL_MACHINE with type Type9
For node: writeStringValue(systemRoot,hkey,key,valueName,value) expected fqn: void with type: Type12 got: void
Cannot find matching typeVariable for: writeStringValue
For node: writeStringValue expected fqn: void with type: Type12 got: void
Cannot find matching typeVariable for: systemRoot
For node: systemRoot expected fqn: java.util.prefs.Preferences with type: Type12 got: void
Cannot find matching typeVariable for: hkey
For node: hkey expected fqn: int with type: Type12 got: void
Cannot find matching typeVariable for: key
For node: key expected fqn: java.lang.String with type: Type12 got: void
Cannot find matching typeVariable for: valueName
For node: valueName expected fqn: java.lang.String with type: Type12 got: void
Cannot find matching typeVariable for: value
For node: value expected fqn: java.lang.String with type: Type12 got: void
For node: hkey == HKEY_CURRENT_USER expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_CURRENT_USER with type Type9
For node: writeStringValue(userRoot,hkey,key,valueName,value) expected fqn: void with type: Type12 got: void
Cannot find matching typeVariable for: writeStringValue
For node: writeStringValue expected fqn: void with type: Type12 got: void
Cannot find matching typeVariable for: userRoot
For node: userRoot expected fqn: java.util.prefs.Preferences with type: Type12 got: void
Cannot find matching typeVariable for: hkey
For node: hkey expected fqn: int with type: Type12 got: void
Cannot find matching typeVariable for: key
For node: key expected fqn: java.lang.String with type: Type12 got: void
Cannot find matching typeVariable for: valueName
For node: valueName expected fqn: java.lang.String with type: Type12 got: void
Cannot find matching typeVariable for: value
For node: value expected fqn: java.lang.String with type: Type12 got: void
Did not find solution for node: new IllegalArgumentException("hkey=" + hkey) with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: "hkey=" + hkey with type Type92
Did not find solution for node: "hkey=" with type Type92
Did not find solution for node: hkey with type Type9
For node: void expected fqn: void with type: Type12 got: void
Cannot find matching typeVariable for: deleteKey
Cannot find matching typeVariable for: /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
public static void deleteKey(int hkey,String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  int rc=-1;
  if (hkey == HKEY_LOCAL_MACHINE) {
    rc=deleteKey(systemRoot,hkey,key);
  }
 else   if (hkey == HKEY_CURRENT_USER) {
    rc=deleteKey(userRoot,hkey,key);
  }
  if (rc != REG_SUCCESS) {
    throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
  }
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: rc=-1
Did not find solution for node: rc=-1 with type Type9
Did not find solution for node: rc with type Type9
Did not find solution for node: -1 with type Type7
Did not find solution for node: 1 with type Type7
For node: hkey == HKEY_LOCAL_MACHINE expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_LOCAL_MACHINE with type Type9
Did not find solution for node: rc=deleteKey(systemRoot,hkey,key) with type Type9
Did not find solution for node: rc with type Type9
Did not find solution for node: deleteKey(systemRoot,hkey,key) with type Type9
Cannot find matching typeVariable for: deleteKey
Did not find solution for node: deleteKey with type Type9
Cannot find matching typeVariable for: systemRoot
Did not find solution for node: systemRoot with type Type9
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type9
For node: hkey == HKEY_CURRENT_USER expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_CURRENT_USER with type Type9
Did not find solution for node: rc=deleteKey(userRoot,hkey,key) with type Type9
Did not find solution for node: rc with type Type9
Did not find solution for node: deleteKey(userRoot,hkey,key) with type Type9
Cannot find matching typeVariable for: deleteKey
Did not find solution for node: deleteKey with type Type9
Cannot find matching typeVariable for: userRoot
Did not find solution for node: userRoot with type Type9
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type9
For node: rc != REG_SUCCESS expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: rc with type Type9
Did not find solution for node: REG_SUCCESS with type Type9
Did not find solution for node: new IllegalArgumentException("rc=" + rc + "  key="+ key) with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: "rc=" + rc + "  key="+ key with type Type92
Did not find solution for node: "rc=" with type Type92
Did not find solution for node: rc with type Type9
Did not find solution for node: "  key=" with type Type92
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type92
For node: void expected fqn: void with type: Type12 got: void
Cannot find matching typeVariable for: deleteValue
Cannot find matching typeVariable for: /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
public static void deleteValue(int hkey,String key,String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  int rc=-1;
  if (hkey == HKEY_LOCAL_MACHINE) {
    rc=deleteValue(systemRoot,hkey,key,value);
  }
 else   if (hkey == HKEY_CURRENT_USER) {
    rc=deleteValue(userRoot,hkey,key,value);
  }
  if (rc != REG_SUCCESS) {
    throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
  }
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Cannot find matching typeVariable for: String value
Did not find solution for node: String value with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: value with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: rc=-1
Did not find solution for node: rc=-1 with type Type9
Did not find solution for node: rc with type Type9
Did not find solution for node: -1 with type Type7
Did not find solution for node: 1 with type Type7
For node: hkey == HKEY_LOCAL_MACHINE expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_LOCAL_MACHINE with type Type9
Did not find solution for node: rc=deleteValue(systemRoot,hkey,key,value) with type Type9
Did not find solution for node: rc with type Type9
Did not find solution for node: deleteValue(systemRoot,hkey,key,value) with type Type9
Cannot find matching typeVariable for: deleteValue
Did not find solution for node: deleteValue with type Type9
Cannot find matching typeVariable for: systemRoot
Did not find solution for node: systemRoot with type Type9
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type9
Cannot find matching typeVariable for: value
Did not find solution for node: value with type Type9
For node: hkey == HKEY_CURRENT_USER expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: hkey with type Type9
Did not find solution for node: HKEY_CURRENT_USER with type Type9
Did not find solution for node: rc=deleteValue(userRoot,hkey,key,value) with type Type9
Did not find solution for node: rc with type Type9
Did not find solution for node: deleteValue(userRoot,hkey,key,value) with type Type9
Cannot find matching typeVariable for: deleteValue
Did not find solution for node: deleteValue with type Type9
Cannot find matching typeVariable for: userRoot
Did not find solution for node: userRoot with type Type9
Cannot find matching typeVariable for: hkey
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type9
Cannot find matching typeVariable for: value
Did not find solution for node: value with type Type9
For node: rc != REG_SUCCESS expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: rc with type Type9
Did not find solution for node: REG_SUCCESS with type Type9
Did not find solution for node: new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value) with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: "rc=" + rc + "  key="+ key+ "  value="+ value with type Type92
Did not find solution for node: "rc=" with type Type92
Did not find solution for node: rc with type Type9
Did not find solution for node: "  key=" with type Type92
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type92
Did not find solution for node: "  value=" with type Type92
Cannot find matching typeVariable for: value
Did not find solution for node: value with type Type92
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: deleteValue
Cannot find matching typeVariable for: private static int deleteValue(Preferences root,int hkey,String key,String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
  if (handles[1] != REG_SUCCESS) {
    return handles[1];
  }
  int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
  regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  return rc;
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: Preferences root
For node: Preferences root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Cannot find matching typeVariable for: String value
Did not find solution for node: String value with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: value with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)})
Did not find solution for node: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)}) with type Type10
Did not find solution for node: handles with type Type10
Did not find solution for node: (int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)}) with type Type10
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Did not find solution for node: regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)}) with type Type148
For node: regOpenKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)} with type Type152
Did not find solution for node: new Integer(hkey) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: hkey with type Type9
Did not find solution for node: toCstr(key) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type8
Did not find solution for node: new Integer(KEY_ALL_ACCESS) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: KEY_ALL_ACCESS with type Type9
For node: handles[1] != REG_SUCCESS expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: handles[1] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 1 with type Type7
Did not find solution for node: REG_SUCCESS with type Type9
Did not find solution for node: handles[1] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 1 with type Type7
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue()
Did not find solution for node: rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue() with type Type9
Did not find solution for node: rc with type Type9
For node: ((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue() expected fqn: int with type: Type156 got: int
Did not find solution for node: ((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})) with type Type140
Did not find solution for node: (Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)}) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)}) with type Type148
For node: regDeleteValue expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0]),toCstr(value)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0]),toCstr(value)} with type Type154
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: toCstr(value) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: value
Did not find solution for node: value with type Type8
Cannot find matching typeVariable for: intValue
For node: intValue expected fqn: int with type: Type156 got: int
Did not find solution for node: regCloseKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type148
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0])} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0])} with type Type158
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: rc with type Type9
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: deleteKey
Cannot find matching typeVariable for: private static int deleteKey(Preferences root,int hkey,String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
  return rc;
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: Preferences root
For node: Preferences root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue()
Did not find solution for node: rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue() with type Type9
Did not find solution for node: rc with type Type9
Did not find solution for node: ((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue() with type Type157
Did not find solution for node: ((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})) with type Type140
Did not find solution for node: (Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)}) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)}) with type Type148
For node: regDeleteKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(hkey),toCstr(key)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(hkey),toCstr(key)} with type Type160
Did not find solution for node: new Integer(hkey) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: hkey with type Type9
Did not find solution for node: toCstr(key) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type8
Cannot find matching typeVariable for: intValue
Did not find solution for node: intValue with type Type157
Did not find solution for node: rc with type Type9
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: readString
Cannot find matching typeVariable for: private static String readString(Preferences root,int hkey,String key,String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
  if (handles[1] != REG_SUCCESS) {
    return null;
  }
  byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
  regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  return (valb != null ? new String(valb).trim() : null);
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: Preferences root
For node: Preferences root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Cannot find matching typeVariable for: String value
Did not find solution for node: String value with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: value with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)})
Did not find solution for node: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)}) with type Type10
Did not find solution for node: handles with type Type10
Did not find solution for node: (int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)}) with type Type10
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Did not find solution for node: regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)}) with type Type148
For node: regOpenKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(hkey),toCstr(key),new Integer(KEY_READ)} with type Type162
Did not find solution for node: new Integer(hkey) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: hkey with type Type9
Did not find solution for node: toCstr(key) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type8
Did not find solution for node: new Integer(KEY_READ) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: KEY_READ with type Type9
For node: handles[1] != REG_SUCCESS expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: handles[1] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 1 with type Type7
Did not find solution for node: REG_SUCCESS with type Type9
For node: null expected fqn: null with type: Type164 got: java.lang.String
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
Cannot find matching typeVariable for: valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})
Did not find solution for node: valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)}) with type Type8
Did not find solution for node: valb with type Type8
Did not find solution for node: (byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)}) with type Type8
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
Did not find solution for node: regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)}) with type Type148
For node: regQueryValueEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0]),toCstr(value)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0]),toCstr(value)} with type Type165
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: toCstr(value) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: value
Did not find solution for node: value with type Type8
Did not find solution for node: regCloseKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type148
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0])} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0])} with type Type167
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
For node: (valb != null ? new String(valb).trim() : null) expected fqn: java.lang.String with type: Type175 got: java.lang.Boolean
For node: valb != null ? new String(valb).trim() : null expected fqn: java.lang.String with type: Type175 got: java.lang.Boolean
For node: valb != null expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: valb with type Type8
Did not find solution for node: null with type Type169
For node: new String(valb).trim() expected fqn: java.lang.String with type: Type172 got: java.lang.String
Did not find solution for node: new String(valb) with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: valb with type Type8
Cannot find matching typeVariable for: trim
For node: trim expected fqn: java.lang.String with type: Type172 got: java.lang.String
Did not find solution for node: null with type Type174
Did not find solution for node: Map<String,String> with type Type4=Type2<Type3,Type3>
For node: Map expected fqn: java.util.Map<java.lang.String,java.lang.String> with type: Type2 got: java.util.Map
For node: Map expected fqn: java.util.Map<java.lang.String,java.lang.String> with type: Type2 got: java.util.Map
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: readStringValues
Cannot find matching typeVariable for: private static Map<String,String> readStringValues(Preferences root,int hkey,String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  HashMap<String,String> results=new HashMap<String,String>();
  int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
  if (handles[1] != REG_SUCCESS) {
    return null;
  }
  int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
  int count=info[0];
  int maxlen=info[3];
  for (int index=0; index < count; index++) {
    byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
    String value=readString(hkey,key,new String(name));
    results.put(new String(name).trim(),value);
  }
  regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  return results;
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: Preferences root
For node: Preferences root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: HashMap<String,String> with type Type177=Type176<Type92,Type92>
For node: HashMap expected fqn: java.util.HashMap<java.lang.String,java.lang.String> with type: Type176 got: java.util.HashMap
For node: HashMap expected fqn: java.util.HashMap<java.lang.String,java.lang.String> with type: Type176 got: java.util.HashMap
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Cannot find matching typeVariable for: results=new HashMap<String,String>()
Did not find solution for node: results=new HashMap<String,String>() with type Type177=Type176<Type92,Type92>
Did not find solution for node: results with type Type177=Type176<Type92,Type92>
Did not find solution for node: new HashMap<String,String>() with type Type177=Type176<Type92,Type92>
Did not find solution for node: HashMap<String,String> with type Type177=Type176<Type92,Type92>
For node: HashMap expected fqn: java.util.HashMap<java.lang.String,java.lang.String> with type: Type176 got: java.util.HashMap
For node: HashMap expected fqn: java.util.HashMap<java.lang.String,java.lang.String> with type: Type176 got: java.util.HashMap
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)})
Did not find solution for node: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)}) with type Type10
Did not find solution for node: handles with type Type10
Did not find solution for node: (int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)}) with type Type10
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Did not find solution for node: regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)}) with type Type148
For node: regOpenKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(hkey),toCstr(key),new Integer(KEY_READ)} with type Type181
Did not find solution for node: new Integer(hkey) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: hkey with type Type9
Did not find solution for node: toCstr(key) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type8
Did not find solution for node: new Integer(KEY_READ) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: KEY_READ with type Type9
For node: handles[1] != REG_SUCCESS expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: handles[1] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 1 with type Type7
Did not find solution for node: REG_SUCCESS with type Type9
For node: null expected fqn: null with type: Type183 got: java.util.Map
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])})
Did not find solution for node: info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type10
Did not find solution for node: info with type Type10
Did not find solution for node: (int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type10
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Did not find solution for node: regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type148
For node: regQueryInfoKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0])} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0])} with type Type184
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: count=info[0]
Did not find solution for node: count=info[0] with type Type9
Did not find solution for node: count with type Type9
Did not find solution for node: info[0] with type Type9
Did not find solution for node: info with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: maxlen=info[3]
Did not find solution for node: maxlen=info[3] with type Type9
Did not find solution for node: maxlen with type Type9
Did not find solution for node: info[3] with type Type9
Did not find solution for node: info with type Type10
Did not find solution for node: 3 with type Type7
Cannot find matching typeVariable for: int index=0
Did not find solution for node: int index=0 with type Type9
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: index=0
Did not find solution for node: index=0 with type Type9
Did not find solution for node: index with type Type9
Did not find solution for node: 0 with type Type7
For node: index < count expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: index with type Type9
Did not find solution for node: count with type Type9
Did not find solution for node: index++ with type Type9
Did not find solution for node: index with type Type9
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
Cannot find matching typeVariable for: name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)})
Did not find solution for node: name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)}) with type Type8
Did not find solution for node: name with type Type8
Did not find solution for node: (byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)}) with type Type8
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
Did not find solution for node: regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)}) with type Type148
For node: regEnumValue expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)} with type Type186
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: new Integer(index) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: index with type Type9
Did not find solution for node: new Integer(maxlen + 1) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: maxlen + 1 with type Type9
Did not find solution for node: maxlen with type Type9
Did not find solution for node: 1 with type Type7
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Cannot find matching typeVariable for: value=readString(hkey,key,new String(name))
Did not find solution for node: value=readString(hkey,key,new String(name)) with type Type92
Did not find solution for node: value with type Type92
For node: readString(hkey,key,new String(name)) expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: readString
For node: readString expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: hkey
For node: hkey expected fqn: int with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: key
For node: key expected fqn: java.lang.String with type: Type3 got: java.lang.String
Did not find solution for node: new String(name) with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: name with type Type8
Did not find solution for node: results.put(new String(name).trim(),value) with type Type188
Did not find solution for node: results with type Type177=Type176<Type92,Type92>
Cannot find matching typeVariable for: put
Did not find solution for node: put with type Type188
Did not find solution for node: new String(name).trim() with type Type173
Did not find solution for node: new String(name) with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: name with type Type8
Cannot find matching typeVariable for: trim
Did not find solution for node: trim with type Type173
Did not find solution for node: value with type Type92
Did not find solution for node: regCloseKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type148
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0])} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0])} with type Type196
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: results with type Type177=Type176<Type92,Type92>
Did not find solution for node: List<String> with type Type6=Type5<Type3>
For node: List expected fqn: java.util.List<java.lang.String> with type: Type5 got: java.util.List
For node: List expected fqn: java.util.List<java.lang.String> with type: Type5 got: java.util.List
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: readStringSubKeys
Cannot find matching typeVariable for: private static List<String> readStringSubKeys(Preferences root,int hkey,String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  List<String> results=new ArrayList<String>();
  int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
  if (handles[1] != REG_SUCCESS) {
    return null;
  }
  int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
  int count=info[0];
  int maxlen=info[3];
  for (int index=0; index < count; index++) {
    byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
    results.add(new String(name).trim());
  }
  regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  return results;
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: Preferences root
For node: Preferences root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: List<String> with type Type137=Type5<Type92>
For node: List expected fqn: java.util.List<java.lang.String> with type: Type5 got: java.util.List
For node: List expected fqn: java.util.List<java.lang.String> with type: Type5 got: java.util.List
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Cannot find matching typeVariable for: results=new ArrayList<String>()
Did not find solution for node: results=new ArrayList<String>() with type Type137=Type5<Type92>
Did not find solution for node: results with type Type137=Type5<Type92>
Did not find solution for node: new ArrayList<String>() with type Type199=Type198<Type92>
Did not find solution for node: ArrayList<String> with type Type199=Type198<Type92>
For node: ArrayList expected fqn: java.util.ArrayList<java.lang.String> with type: Type198 got: java.util.ArrayList
For node: ArrayList expected fqn: java.util.ArrayList<java.lang.String> with type: Type198 got: java.util.ArrayList
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)})
Did not find solution for node: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)}) with type Type10
Did not find solution for node: handles with type Type10
Did not find solution for node: (int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)}) with type Type10
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Did not find solution for node: regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)}) with type Type148
For node: regOpenKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(hkey),toCstr(key),new Integer(KEY_READ)} with type Type203
Did not find solution for node: new Integer(hkey) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: hkey with type Type9
Did not find solution for node: toCstr(key) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type8
Did not find solution for node: new Integer(KEY_READ) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: KEY_READ with type Type9
For node: handles[1] != REG_SUCCESS expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: handles[1] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 1 with type Type7
Did not find solution for node: REG_SUCCESS with type Type9
Did not find solution for node: null with type Type205
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])})
Did not find solution for node: info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type10
Did not find solution for node: info with type Type10
Did not find solution for node: (int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type10
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Did not find solution for node: regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type148
For node: regQueryInfoKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0])} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0])} with type Type206
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: count=info[0]
Did not find solution for node: count=info[0] with type Type9
Did not find solution for node: count with type Type9
Did not find solution for node: info[0] with type Type9
Did not find solution for node: info with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: maxlen=info[3]
Did not find solution for node: maxlen=info[3] with type Type9
Did not find solution for node: maxlen with type Type9
Did not find solution for node: info[3] with type Type9
Did not find solution for node: info with type Type10
Did not find solution for node: 3 with type Type7
Cannot find matching typeVariable for: int index=0
Did not find solution for node: int index=0 with type Type9
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: index=0
Did not find solution for node: index=0 with type Type9
Did not find solution for node: index with type Type9
Did not find solution for node: 0 with type Type7
For node: index < count expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: index with type Type9
Did not find solution for node: count with type Type9
Did not find solution for node: index++ with type Type9
Did not find solution for node: index with type Type9
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
Cannot find matching typeVariable for: name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)})
Did not find solution for node: name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)}) with type Type8
Did not find solution for node: name with type Type8
Did not find solution for node: (byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)}) with type Type8
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
Did not find solution for node: regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)}) with type Type148
For node: regEnumKeyEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)} with type Type208
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: new Integer(index) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: index with type Type9
Did not find solution for node: new Integer(maxlen + 1) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: maxlen + 1 with type Type9
Did not find solution for node: maxlen with type Type9
Did not find solution for node: 1 with type Type7
Did not find solution for node: results.add(new String(name).trim()) with type Type210
Did not find solution for node: results with type Type137=Type5<Type92>
Cannot find matching typeVariable for: add
Did not find solution for node: add with type Type210
Did not find solution for node: new String(name).trim() with type Type173
Did not find solution for node: new String(name) with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: name with type Type8
Cannot find matching typeVariable for: trim
Did not find solution for node: trim with type Type173
Did not find solution for node: regCloseKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type148
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0])} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0])} with type Type216
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: results with type Type137=Type5<Type92>
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: createKey
Cannot find matching typeVariable for: private static int[] createKey(Preferences root,int hkey,String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: Preferences root
For node: Preferences root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)}) with type Type10
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Did not find solution for node: regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)}) with type Type148
For node: regCreateKeyEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(hkey),toCstr(key)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(hkey),toCstr(key)} with type Type218
Did not find solution for node: new Integer(hkey) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: hkey with type Type9
Did not find solution for node: toCstr(key) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type8
For node: void expected fqn: void with type: Type12 got: void
Cannot find matching typeVariable for: writeStringValue
Cannot find matching typeVariable for: private static void writeStringValue(Preferences root,int hkey,String key,String valueName,String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
  int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
  regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
  regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: Preferences root
For node: Preferences root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: Preferences expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Cannot find matching typeVariable for: int hkey
Did not find solution for node: int hkey with type Type9
Did not find solution for node: int with type Type9
Did not find solution for node: hkey with type Type9
Cannot find matching typeVariable for: String key
Did not find solution for node: String key with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: key with type Type92
Cannot find matching typeVariable for: String valueName
Did not find solution for node: String valueName with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: valueName with type Type92
Cannot find matching typeVariable for: String value
Did not find solution for node: String value with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: value with type Type92
Did not find solution for node: IllegalArgumentException with type Type131
Did not find solution for node: IllegalArgumentException with type Type131
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: IllegalAccessException expected fqn: java.lang.IllegalAccessException with type: Type132 got: java.lang.IllegalAccessException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
For node: InvocationTargetException expected fqn: java.lang.reflect.InvocationTargetException with type: Type133 got: java.lang.reflect.InvocationTargetException
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)})
Did not find solution for node: handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)}) with type Type10
Did not find solution for node: handles with type Type10
Did not find solution for node: (int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)}) with type Type10
Did not find solution for node: int[] with type Type10
Did not find solution for node: int with type Type9
Did not find solution for node: regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)}) with type Type148
For node: regOpenKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)} with type Type220
Did not find solution for node: new Integer(hkey) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: hkey with type Type9
Did not find solution for node: toCstr(key) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: key
Did not find solution for node: key with type Type8
Did not find solution for node: new Integer(KEY_ALL_ACCESS) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: KEY_ALL_ACCESS with type Type9
Did not find solution for node: regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)}) with type Type148
For node: regSetValueEx expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0]),toCstr(valueName),toCstr(value)} with type Type222
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: toCstr(valueName) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: valueName
Did not find solution for node: valueName with type Type8
Did not find solution for node: toCstr(value) with type Type8
Cannot find matching typeVariable for: toCstr
Did not find solution for node: toCstr with type Type8
Cannot find matching typeVariable for: value
Did not find solution for node: value with type Type8
Did not find solution for node: regCloseKey.invoke(root,new Object[]{new Integer(handles[0])}) with type Type148
For node: regCloseKey expected fqn: java.lang.reflect.Method with type: Type83 got: java.lang.reflect.Method
Cannot find matching typeVariable for: invoke
Did not find solution for node: invoke with type Type148
For node: root expected fqn: java.util.prefs.Preferences with type: Type79 got: java.util.prefs.Preferences
Did not find solution for node: new Object[]{new Integer(handles[0])} with type Type139
Did not find solution for node: Object[] with type Type139
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
For node: Object expected fqn: java.lang.Object with type: Type138 got: java.lang.Object
Did not find solution for node: {new Integer(handles[0])} with type Type224
Did not find solution for node: new Integer(handles[0]) with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: Integer with type Type140
Did not find solution for node: handles[0] with type Type9
Did not find solution for node: handles with type Type10
Did not find solution for node: 0 with type Type7
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
Cannot find matching typeVariable for: toCstr
Cannot find matching typeVariable for: private static byte[] toCstr(String str){
  byte[] result=new byte[str.length() + 1];
  for (int i=0; i < str.length(); i++) {
    result[i]=(byte)str.charAt(i);
  }
  result[str.length()]=0;
  return result;
}

Cannot find matching typeVariable for: public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.prefs.Preferences;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
public class Class_16 {
  public static final int HKEY_CURRENT_USER=0x80000001;
  public static final int HKEY_LOCAL_MACHINE=0x80000002;
  public static final int REG_SUCCESS=0;
  public static final int REG_NOTFOUND=2;
  public static final int REG_ACCESSDENIED=5;
  private static final int KEY_ALL_ACCESS=0xf003f;
  private static final int KEY_READ=0x20019;
  private static final Preferences userRoot=Preferences.userRoot();
  private static final Preferences systemRoot=Preferences.systemRoot();
  private static final Class<? extends Preferences> userClass=userRoot.getClass();
  private static final Method regOpenKey;
  private static final Method regCloseKey;
  private static final Method regQueryValueEx;
  private static final Method regEnumValue;
  private static final Method regQueryInfoKey;
  private static final Method regEnumKeyEx;
  private static final Method regCreateKeyEx;
  private static final Method regSetValueEx;
  private static final Method regDeleteKey;
  private static final Method regDeleteValue;
static {
    try {
      regOpenKey=userClass.getDeclaredMethod("WindowsRegOpenKey",new Class[]{int.class,byte[].class,int.class});
      regOpenKey.setAccessible(true);
      regCloseKey=userClass.getDeclaredMethod("WindowsRegCloseKey",new Class[]{int.class});
      regCloseKey.setAccessible(true);
      regQueryValueEx=userClass.getDeclaredMethod("WindowsRegQueryValueEx",new Class[]{int.class,byte[].class});
      regQueryValueEx.setAccessible(true);
      regEnumValue=userClass.getDeclaredMethod("WindowsRegEnumValue",new Class[]{int.class,int.class,int.class});
      regEnumValue.setAccessible(true);
      regQueryInfoKey=userClass.getDeclaredMethod("WindowsRegQueryInfoKey1",new Class[]{int.class});
      regQueryInfoKey.setAccessible(true);
      regEnumKeyEx=userClass.getDeclaredMethod("WindowsRegEnumKeyEx",new Class[]{int.class,int.class,int.class});
      regEnumKeyEx.setAccessible(true);
      regCreateKeyEx=userClass.getDeclaredMethod("WindowsRegCreateKeyEx",new Class[]{int.class,byte[].class});
      regCreateKeyEx.setAccessible(true);
      regSetValueEx=userClass.getDeclaredMethod("WindowsRegSetValueEx",new Class[]{int.class,byte[].class,byte[].class});
      regSetValueEx.setAccessible(true);
      regDeleteValue=userClass.getDeclaredMethod("WindowsRegDeleteValue",new Class[]{int.class,byte[].class});
      regDeleteValue.setAccessible(true);
      regDeleteKey=userClass.getDeclaredMethod("WindowsRegDeleteKey",new Class[]{int.class,byte[].class});
      regDeleteKey.setAccessible(true);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  private Class_16(){
  }
  /** 
 * Read a value from key and value name
 * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @param valueName
 * @return the value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static String readString(  int hkey,  String key,  String valueName) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readString(systemRoot,hkey,key,valueName);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readString(userRoot,hkey,key,valueName);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read value(s) and value name(s) form given key 
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s) plus the value(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static Map<String,String> readStringValues(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringValues(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringValues(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Read the value name(s) from a given key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @return the value name(s)
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static List<String> readStringSubKeys(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      return readStringSubKeys(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      return readStringSubKeys(userRoot,hkey,key);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Create a key
 * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void createKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] ret;
    if (hkey == HKEY_LOCAL_MACHINE) {
      ret=createKey(systemRoot,hkey,key);
      regCloseKey.invoke(systemRoot,new Object[]{new Integer(ret[0])});
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      ret=createKey(userRoot,hkey,key);
      regCloseKey.invoke(userRoot,new Object[]{new Integer(ret[0])});
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
    if (ret[1] != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + ret[1] + "  key="+ key);
    }
  }
  /** 
 * Write a value in a given key/value name
 * @param hkey
 * @param key
 * @param valueName
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void writeStringValue(  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    if (hkey == HKEY_LOCAL_MACHINE) {
      writeStringValue(systemRoot,hkey,key,valueName,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      writeStringValue(userRoot,hkey,key,valueName,value);
    }
 else {
      throw new IllegalArgumentException("hkey=" + hkey);
    }
  }
  /** 
 * Delete a given key
 * @param hkey
 * @param key
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteKey(  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteKey(systemRoot,hkey,key);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteKey(userRoot,hkey,key);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key);
    }
  }
  /** 
 * delete a value from a given key/value name
 * @param hkey
 * @param key
 * @param value
 * @throws IllegalArgumentException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
  public static void deleteValue(  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=-1;
    if (hkey == HKEY_LOCAL_MACHINE) {
      rc=deleteValue(systemRoot,hkey,key,value);
    }
 else     if (hkey == HKEY_CURRENT_USER) {
      rc=deleteValue(userRoot,hkey,key,value);
    }
    if (rc != REG_SUCCESS) {
      throw new IllegalArgumentException("rc=" + rc + "  key="+ key+ "  value="+ value);
    }
  }
  private static int deleteValue(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    if (handles[1] != REG_SUCCESS) {
      return handles[1];
    }
    int rc=((Integer)regDeleteValue.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)})).intValue();
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return rc;
  }
  private static int deleteKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int rc=((Integer)regDeleteKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key)})).intValue();
    return rc;
  }
  private static String readString(  Preferences root,  int hkey,  String key,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    byte[] valb=(byte[])regQueryValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return (valb != null ? new String(valb).trim() : null);
  }
  private static Map<String,String> readStringValues(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    HashMap<String,String> results=new HashMap<String,String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumValue.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      String value=readString(hkey,key,new String(name));
      results.put(new String(name).trim(),value);
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static List<String> readStringSubKeys(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    List<String> results=new ArrayList<String>();
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_READ)});
    if (handles[1] != REG_SUCCESS) {
      return null;
    }
    int[] info=(int[])regQueryInfoKey.invoke(root,new Object[]{new Integer(handles[0])});
    int count=info[0];
    int maxlen=info[3];
    for (int index=0; index < count; index++) {
      byte[] name=(byte[])regEnumKeyEx.invoke(root,new Object[]{new Integer(handles[0]),new Integer(index),new Integer(maxlen + 1)});
      results.add(new String(name).trim());
    }
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
    return results;
  }
  private static int[] createKey(  Preferences root,  int hkey,  String key) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    return (int[])regCreateKeyEx.invoke(root,new Object[]{new Integer(hkey),toCstr(key)});
  }
  private static void writeStringValue(  Preferences root,  int hkey,  String key,  String valueName,  String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    int[] handles=(int[])regOpenKey.invoke(root,new Object[]{new Integer(hkey),toCstr(key),new Integer(KEY_ALL_ACCESS)});
    regSetValueEx.invoke(root,new Object[]{new Integer(handles[0]),toCstr(valueName),toCstr(value)});
    regCloseKey.invoke(root,new Object[]{new Integer(handles[0])});
  }
  private static byte[] toCstr(  String str){
    byte[] result=new byte[str.length() + 1];
    for (int i=0; i < str.length(); i++) {
      result[i]=(byte)str.charAt(i);
    }
    result[str.length()]=0;
    return result;
  }
}

Cannot find matching typeVariable for: String str
Did not find solution for node: String str with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: String with type Type92
Did not find solution for node: str with type Type92
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
Cannot find matching typeVariable for: result=new byte[str.length() + 1]
Did not find solution for node: result=new byte[str.length() + 1] with type Type8
Did not find solution for node: result with type Type8
Did not find solution for node: new byte[str.length() + 1] with type Type8
Did not find solution for node: byte[] with type Type8
Did not find solution for node: byte with type Type7
Did not find solution for node: str.length() + 1 with type Type226
Did not find solution for node: str.length() with type Type226
Did not find solution for node: str with type Type92
Cannot find matching typeVariable for: length
Did not find solution for node: length with type Type226
Did not find solution for node: 1 with type Type7
Cannot find matching typeVariable for: int i=0
Did not find solution for node: int i=0 with type Type9
Did not find solution for node: int with type Type9
Cannot find matching typeVariable for: i=0
Did not find solution for node: i=0 with type Type9
Did not find solution for node: i with type Type9
Did not find solution for node: 0 with type Type7
For node: i < str.length() expected fqn: boolean with type: Type105 got: boolean
Did not find solution for node: i with type Type9
Did not find solution for node: str.length() with type Type227
Did not find solution for node: str with type Type92
Cannot find matching typeVariable for: length
Did not find solution for node: length with type Type227
Did not find solution for node: i++ with type Type9
Did not find solution for node: i with type Type9
Did not find solution for node: result[i]=(byte)str.charAt(i) with type Type7
Did not find solution for node: result[i] with type Type7
Did not find solution for node: result with type Type8
Cannot find matching typeVariable for: i
Did not find solution for node: i with type Type7
Did not find solution for node: (byte)str.charAt(i) with type Type7
Did not find solution for node: byte with type Type7
Did not find solution for node: str.charAt(i) with type Type228
Did not find solution for node: str with type Type92
Cannot find matching typeVariable for: charAt
Did not find solution for node: charAt with type Type228
Did not find solution for node: i with type Type9
Did not find solution for node: result[str.length()]=0 with type Type7
Did not find solution for node: result[str.length()] with type Type7
Did not find solution for node: result with type Type8
Did not find solution for node: str.length() with type Type227
Did not find solution for node: str with type Type92
Cannot find matching typeVariable for: length
Did not find solution for node: length with type Type227
Did not find solution for node: 0 with type Type7
Did not find solution for node: result with type Type8
{Checked=1446, Analyzed=420, Unsolved=1026, Incorrect=58, Correct=362}
=SimpleName: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
boolean=BooleanLiteral: {Checked=10, Analyzed=10, Unsolved=0, Incorrect=0, Correct=10}
boolean=InfixExpression: {Checked=25, Analyzed=25, Unsolved=0, Incorrect=0, Correct=25}
boolean=MethodInvocation: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
boolean=SimpleName: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
byte=ArrayAccess: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
byte=ArrayCreation: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
byte=ArrayType: {Checked=16, Analyzed=0, Unsolved=16, Incorrect=0, Correct=0}
byte=Assignment: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
byte=CastExpression: {Checked=4, Analyzed=0, Unsolved=4, Incorrect=0, Correct=0}
byte=MethodInvocation: {Checked=11, Analyzed=0, Unsolved=11, Incorrect=0, Correct=0}
byte=PrimitiveType: {Checked=17, Analyzed=0, Unsolved=17, Incorrect=0, Correct=0}
byte=SimpleName: {Checked=23, Analyzed=0, Unsolved=23, Incorrect=0, Correct=0}
byte=VariableDeclarationFragment: {Checked=4, Analyzed=0, Unsolved=4, Incorrect=0, Correct=0}
char=MethodInvocation: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
char=SimpleName: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
int=ArrayAccess: {Checked=25, Analyzed=0, Unsolved=25, Incorrect=0, Correct=0}
int=ArrayType: {Checked=17, Analyzed=0, Unsolved=17, Incorrect=0, Correct=0}
int=Assignment: {Checked=6, Analyzed=0, Unsolved=6, Incorrect=0, Correct=0}
int=CastExpression: {Checked=8, Analyzed=0, Unsolved=8, Incorrect=0, Correct=0}
int=InfixExpression: {Checked=3, Analyzed=0, Unsolved=3, Incorrect=0, Correct=0}
int=MethodInvocation: {Checked=11, Analyzed=1, Unsolved=10, Incorrect=0, Correct=1}
int=NumberLiteral: {Checked=41, Analyzed=0, Unsolved=41, Incorrect=0, Correct=0}
int=PostfixExpression: {Checked=3, Analyzed=0, Unsolved=3, Incorrect=0, Correct=0}
int=PrefixExpression: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
int=PrimitiveType: {Checked=66, Analyzed=0, Unsolved=66, Incorrect=0, Correct=0}
int=SimpleName: {Checked=168, Analyzed=6, Unsolved=162, Incorrect=5, Correct=1}
int=SingleVariableDeclaration: {Checked=14, Analyzed=0, Unsolved=14, Incorrect=0, Correct=0}
int=VariableDeclarationExpression: {Checked=3, Analyzed=0, Unsolved=3, Incorrect=0, Correct=0}
int=VariableDeclarationFragment: {Checked=26, Analyzed=0, Unsolved=26, Incorrect=0, Correct=0}
java=ArrayCreation: {Checked=31, Analyzed=0, Unsolved=31, Incorrect=0, Correct=0}
java=ArrayInitializer: {Checked=31, Analyzed=0, Unsolved=31, Incorrect=0, Correct=0}
java=ArrayType: {Checked=31, Analyzed=0, Unsolved=31, Incorrect=0, Correct=0}
java=Assignment: {Checked=10, Analyzed=10, Unsolved=0, Incorrect=0, Correct=10}
java=CastExpression: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
java=ClassInstanceCreation: {Checked=45, Analyzed=1, Unsolved=44, Incorrect=0, Correct=1}
java=ConditionalExpression: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=1, Correct=0}
java=InfixExpression: {Checked=8, Analyzed=0, Unsolved=8, Incorrect=0, Correct=0}
java=MethodInvocation: {Checked=45, Analyzed=8, Unsolved=37, Incorrect=0, Correct=8}
java=ParameterizedType: {Checked=9, Analyzed=0, Unsolved=9, Incorrect=0, Correct=0}
java=ParenthesizedExpression: {Checked=3, Analyzed=1, Unsolved=2, Incorrect=1, Correct=0}
java=SimpleName: {Checked=405, Analyzed=191, Unsolved=214, Incorrect=18, Correct=173}
java=SimpleType: {Checked=186, Analyzed=92, Unsolved=94, Incorrect=8, Correct=84}
java=SingleVariableDeclaration: {Checked=31, Analyzed=8, Unsolved=23, Incorrect=0, Correct=8}
java=StringLiteral: {Checked=22, Analyzed=0, Unsolved=22, Incorrect=0, Correct=0}
java=TypeLiteral: {Checked=22, Analyzed=22, Unsolved=0, Incorrect=22, Correct=0}
java=VariableDeclarationFragment: {Checked=16, Analyzed=12, Unsolved=4, Incorrect=0, Correct=12}
java=WildcardType: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=1, Correct=0}
null=NullLiteral: {Checked=5, Analyzed=2, Unsolved=3, Incorrect=2, Correct=0}
void=MethodInvocation: {Checked=12, Analyzed=12, Unsolved=0, Incorrect=0, Correct=12}
void=PrimitiveType: {Checked=5, Analyzed=5, Unsolved=0, Incorrect=0, Correct=5}
void=SimpleName: {Checked=12, Analyzed=12, Unsolved=0, Incorrect=0, Correct=12}
Total stats
{Checked=1446, Analyzed=420, Unsolved=1026, Incorrect=58, Correct=362}
=SimpleName: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
boolean=BooleanLiteral: {Checked=10, Analyzed=10, Unsolved=0, Incorrect=0, Correct=10}
boolean=InfixExpression: {Checked=25, Analyzed=25, Unsolved=0, Incorrect=0, Correct=25}
boolean=MethodInvocation: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
boolean=SimpleName: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
byte=ArrayAccess: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
byte=ArrayCreation: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
byte=ArrayType: {Checked=16, Analyzed=0, Unsolved=16, Incorrect=0, Correct=0}
byte=Assignment: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
byte=CastExpression: {Checked=4, Analyzed=0, Unsolved=4, Incorrect=0, Correct=0}
byte=MethodInvocation: {Checked=11, Analyzed=0, Unsolved=11, Incorrect=0, Correct=0}
byte=PrimitiveType: {Checked=17, Analyzed=0, Unsolved=17, Incorrect=0, Correct=0}
byte=SimpleName: {Checked=23, Analyzed=0, Unsolved=23, Incorrect=0, Correct=0}
byte=VariableDeclarationFragment: {Checked=4, Analyzed=0, Unsolved=4, Incorrect=0, Correct=0}
char=MethodInvocation: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
char=SimpleName: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
int=ArrayAccess: {Checked=25, Analyzed=0, Unsolved=25, Incorrect=0, Correct=0}
int=ArrayType: {Checked=17, Analyzed=0, Unsolved=17, Incorrect=0, Correct=0}
int=Assignment: {Checked=6, Analyzed=0, Unsolved=6, Incorrect=0, Correct=0}
int=CastExpression: {Checked=8, Analyzed=0, Unsolved=8, Incorrect=0, Correct=0}
int=InfixExpression: {Checked=3, Analyzed=0, Unsolved=3, Incorrect=0, Correct=0}
int=MethodInvocation: {Checked=11, Analyzed=1, Unsolved=10, Incorrect=0, Correct=1}
int=NumberLiteral: {Checked=41, Analyzed=0, Unsolved=41, Incorrect=0, Correct=0}
int=PostfixExpression: {Checked=3, Analyzed=0, Unsolved=3, Incorrect=0, Correct=0}
int=PrefixExpression: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
int=PrimitiveType: {Checked=66, Analyzed=0, Unsolved=66, Incorrect=0, Correct=0}
int=SimpleName: {Checked=168, Analyzed=6, Unsolved=162, Incorrect=5, Correct=1}
int=SingleVariableDeclaration: {Checked=14, Analyzed=0, Unsolved=14, Incorrect=0, Correct=0}
int=VariableDeclarationExpression: {Checked=3, Analyzed=0, Unsolved=3, Incorrect=0, Correct=0}
int=VariableDeclarationFragment: {Checked=26, Analyzed=0, Unsolved=26, Incorrect=0, Correct=0}
java=ArrayCreation: {Checked=31, Analyzed=0, Unsolved=31, Incorrect=0, Correct=0}
java=ArrayInitializer: {Checked=31, Analyzed=0, Unsolved=31, Incorrect=0, Correct=0}
java=ArrayType: {Checked=31, Analyzed=0, Unsolved=31, Incorrect=0, Correct=0}
java=Assignment: {Checked=10, Analyzed=10, Unsolved=0, Incorrect=0, Correct=10}
java=CastExpression: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
java=ClassInstanceCreation: {Checked=45, Analyzed=1, Unsolved=44, Incorrect=0, Correct=1}
java=ConditionalExpression: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=1, Correct=0}
java=InfixExpression: {Checked=8, Analyzed=0, Unsolved=8, Incorrect=0, Correct=0}
java=MethodInvocation: {Checked=45, Analyzed=8, Unsolved=37, Incorrect=0, Correct=8}
java=ParameterizedType: {Checked=9, Analyzed=0, Unsolved=9, Incorrect=0, Correct=0}
java=ParenthesizedExpression: {Checked=3, Analyzed=1, Unsolved=2, Incorrect=1, Correct=0}
java=SimpleName: {Checked=405, Analyzed=191, Unsolved=214, Incorrect=18, Correct=173}
java=SimpleType: {Checked=186, Analyzed=92, Unsolved=94, Incorrect=8, Correct=84}
java=SingleVariableDeclaration: {Checked=31, Analyzed=8, Unsolved=23, Incorrect=0, Correct=8}
java=StringLiteral: {Checked=22, Analyzed=0, Unsolved=22, Incorrect=0, Correct=0}
java=TypeLiteral: {Checked=22, Analyzed=22, Unsolved=0, Incorrect=22, Correct=0}
java=VariableDeclarationFragment: {Checked=16, Analyzed=12, Unsolved=4, Incorrect=0, Correct=12}
java=WildcardType: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=1, Correct=0}
null=NullLiteral: {Checked=5, Analyzed=2, Unsolved=3, Incorrect=2, Correct=0}
void=MethodInvocation: {Checked=12, Analyzed=12, Unsolved=0, Incorrect=0, Correct=12}
void=PrimitiveType: {Checked=5, Analyzed=5, Unsolved=0, Incorrect=0, Correct=5}
void=SimpleName: {Checked=12, Analyzed=12, Unsolved=0, Incorrect=0, Correct=12}
,SimpleName,0,1,0,0,1
boolean,BooleanLiteral,10,10,10,0,0
boolean,InfixExpression,25,25,25,0,0
boolean,MethodInvocation,0,1,0,0,1
boolean,SimpleName,0,1,0,0,1
byte,ArrayAccess,0,2,0,0,2
byte,ArrayCreation,0,1,0,0,1
byte,ArrayType,0,16,0,0,16
byte,Assignment,0,2,0,0,2
byte,CastExpression,0,4,0,0,4
byte,MethodInvocation,0,11,0,0,11
byte,PrimitiveType,0,17,0,0,17
byte,SimpleName,0,23,0,0,23
byte,VariableDeclarationFragment,0,4,0,0,4
char,MethodInvocation,0,1,0,0,1
char,SimpleName,0,1,0,0,1
int,ArrayAccess,0,25,0,0,25
int,ArrayType,0,17,0,0,17
int,Assignment,0,6,0,0,6
int,CastExpression,0,8,0,0,8
int,InfixExpression,0,3,0,0,3
int,MethodInvocation,1,11,1,0,10
int,NumberLiteral,0,41,0,0,41
int,PostfixExpression,0,3,0,0,3
int,PrefixExpression,0,2,0,0,2
int,PrimitiveType,0,66,0,0,66
int,SimpleName,6,168,1,5,162
int,SingleVariableDeclaration,0,14,0,0,14
int,VariableDeclarationExpression,0,3,0,0,3
int,VariableDeclarationFragment,0,26,0,0,26
java,ArrayCreation,0,31,0,0,31
java,ArrayInitializer,0,31,0,0,31
java,ArrayType,0,31,0,0,31
java,Assignment,10,10,10,0,0
java,CastExpression,0,2,0,0,2
java,ClassInstanceCreation,1,45,1,0,44
java,ConditionalExpression,1,1,0,1,0
java,InfixExpression,0,8,0,0,8
java,MethodInvocation,8,45,8,0,37
java,ParameterizedType,0,9,0,0,9
java,ParenthesizedExpression,1,3,0,1,2
java,SimpleName,191,405,173,18,214
java,SimpleType,92,186,84,8,94
java,SingleVariableDeclaration,8,31,8,0,23
java,StringLiteral,0,22,0,0,22
java,TypeLiteral,22,22,0,22,0
java,VariableDeclarationFragment,12,16,12,0,4
java,WildcardType,1,1,0,1,0
null,NullLiteral,2,5,0,2,3
void,MethodInvocation,12,12,12,0,0
void,PrimitiveType,5,5,5,0,0
void,SimpleName,12,12,12,0,0
