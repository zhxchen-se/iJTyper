echo package -Dmaven.test.skip=True
package -Dmaven.test.skip=True
echo 'java ${java_d_options} -cp ./target/snr-server-0.0.1-SNAPSHOT.jar:lib/*:target/lib/* org.javelus.snr.toy.CompareBindingAnalysisAndEclipseJDT "${snr_snippets_folder}" "${snr_library_external}" true false' | ./benchmark/set_env.bash
Processing snippet: /iJTyper/Baseline/SnR/benchmark/../src/test/resources/snippets/so/Class_12.java
Expect check=318
Cannot find matching typeVariable for: /** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: Class_12
Cannot find matching typeVariable for: /** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.text.ParseException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
/** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: fromCalendar
Cannot find matching typeVariable for: /** 
 * Transform Calendar to ISO 8601 string. 
 */
public static String fromCalendar(final Calendar calendar){
  Date date=calendar.getTime();
  String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
  return formatted.substring(0,22) + ":" + formatted.substring(22);
}

Cannot find matching typeVariable for: /** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.text.ParseException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
/** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: final Calendar calendar
For node: final Calendar calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
For node: Calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
For node: Calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
For node: calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
Cannot find matching typeVariable for: date=calendar.getTime()
For node: date=calendar.getTime() expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: calendar.getTime() expected fqn: java.util.Date with type: Type6 got: java.util.Date
For node: calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
Cannot find matching typeVariable for: getTime
For node: getTime expected fqn: java.util.Date with type: Type6 got: java.util.Date
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date)
For node: formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date) expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: formatted expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date) expected fqn: java.lang.String with type: Type13 got: java.lang.String
For node: new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ") expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: SimpleDateFormat expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: SimpleDateFormat expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: "yyyy-MM-dd'T'HH:mm:ssZ" expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: format
For node: format expected fqn: java.lang.String with type: Type13 got: java.lang.String
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: formatted.substring(0,22) + ":" + formatted.substring(22) expected fqn: java.lang.String with type: Type17 got: java.lang.String
For node: formatted.substring(0,22) expected fqn: java.lang.String with type: Type17 got: java.lang.String
For node: formatted expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: substring
For node: substring expected fqn: java.lang.String with type: Type17 got: java.lang.String
For node: 0 expected fqn: int with type: Type16 got: byte
For node: 22 expected fqn: int with type: Type16 got: byte
For node: ":" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: formatted.substring(22) expected fqn: java.lang.String with type: Type21 got: java.lang.String
For node: formatted expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: substring
For node: substring expected fqn: java.lang.String with type: Type21 got: java.lang.String
For node: 22 expected fqn: int with type: Type16 got: byte
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: now
Cannot find matching typeVariable for: /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
public static String now(){
  return fromCalendar(GregorianCalendar.getInstance());
}

Cannot find matching typeVariable for: /** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.text.ParseException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
/** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

For node: fromCalendar(GregorianCalendar.getInstance()) expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: fromCalendar
For node: fromCalendar expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: GregorianCalendar.getInstance() expected fqn: java.util.Calendar with type: Type25 got: java.util.Calendar
For node: GregorianCalendar expected fqn: java.util.GregorianCalendar with type: Type24 got: java.util.GregorianCalendar
Cannot find matching typeVariable for: getInstance
For node: getInstance expected fqn: java.util.Calendar with type: Type25 got: java.util.Calendar
For node: Calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
For node: Calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
Cannot find matching typeVariable for: toCalendar
Cannot find matching typeVariable for: /** 
 * Transform ISO 8601 string to Calendar. 
 */
public static Calendar toCalendar(final String iso8601string) throws ParseException {
  Calendar calendar=GregorianCalendar.getInstance();
  String s=iso8601string.replace("Z","+00:00");
  try {
    s=s.substring(0,22) + s.substring(23);
  }
 catch (  IndexOutOfBoundsException e) {
    throw new ParseException("Invalid length",0);
  }
  Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
  calendar.setTime(date);
  return calendar;
}

Cannot find matching typeVariable for: /** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.text.ParseException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
/** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: final String iso8601string
For node: final String iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: ParseException expected fqn: java.text.ParseException with type: Type27 got: java.text.ParseException
For node: ParseException expected fqn: java.text.ParseException with type: Type27 got: java.text.ParseException
For node: Calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
For node: Calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
Cannot find matching typeVariable for: calendar=GregorianCalendar.getInstance()
For node: calendar=GregorianCalendar.getInstance() expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
For node: calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
For node: GregorianCalendar.getInstance() expected fqn: java.util.Calendar with type: Type29 got: java.util.Calendar
For node: GregorianCalendar expected fqn: java.util.GregorianCalendar with type: Type28 got: java.util.GregorianCalendar
Cannot find matching typeVariable for: getInstance
For node: getInstance expected fqn: java.util.Calendar with type: Type29 got: java.util.Calendar
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: s=iso8601string.replace("Z","+00:00")
For node: s=iso8601string.replace("Z","+00:00") expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: s expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string.replace("Z","+00:00") expected fqn: java.lang.String with type: Type31 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: replace
For node: replace expected fqn: java.lang.String with type: Type31 got: java.lang.String
For node: "Z" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: "+00:00" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: s=s.substring(0,22) + s.substring(23) expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: s expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: s.substring(0,22) + s.substring(23) expected fqn: java.lang.String with type: Type35 got: java.lang.String
For node: s.substring(0,22) expected fqn: java.lang.String with type: Type35 got: java.lang.String
For node: s expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: substring
For node: substring expected fqn: java.lang.String with type: Type35 got: java.lang.String
For node: 0 expected fqn: int with type: Type16 got: byte
For node: 22 expected fqn: int with type: Type16 got: byte
For node: s.substring(23) expected fqn: java.lang.String with type: Type39 got: java.lang.String
For node: s expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: substring
For node: substring expected fqn: java.lang.String with type: Type39 got: java.lang.String
For node: 23 expected fqn: int with type: Type16 got: byte
Cannot find matching typeVariable for: IndexOutOfBoundsException e
For node: IndexOutOfBoundsException e expected fqn: java.lang.IndexOutOfBoundsException with type: Type42 got: java.lang.IndexOutOfBoundsException
For node: IndexOutOfBoundsException expected fqn: java.lang.IndexOutOfBoundsException with type: Type42 got: java.lang.IndexOutOfBoundsException
For node: IndexOutOfBoundsException expected fqn: java.lang.IndexOutOfBoundsException with type: Type42 got: java.lang.IndexOutOfBoundsException
For node: e expected fqn: java.lang.IndexOutOfBoundsException with type: Type42 got: java.lang.IndexOutOfBoundsException
For node: new ParseException("Invalid length",0) expected fqn: java.text.ParseException with type: Type27 got: java.text.ParseException
For node: ParseException expected fqn: java.text.ParseException with type: Type27 got: java.text.ParseException
For node: ParseException expected fqn: java.text.ParseException with type: Type27 got: java.text.ParseException
For node: "Invalid length" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: 0 expected fqn: int with type: Type16 got: byte
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
Cannot find matching typeVariable for: date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s)
For node: date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s) expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s) expected fqn: java.util.Date with type: Type46 got: java.util.Date
For node: new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ") expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: SimpleDateFormat expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: SimpleDateFormat expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: "yyyy-MM-dd'T'HH:mm:ssZ" expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: parse
For node: parse expected fqn: java.util.Date with type: Type46 got: java.util.Date
For node: s expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: calendar.setTime(date) expected fqn: void with type: Type49 got: void
For node: calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
Cannot find matching typeVariable for: setTime
For node: setTime expected fqn: void with type: Type49 got: void
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: calendar expected fqn: java.util.Calendar with type: Type4 got: java.util.Calendar
Cannot find matching typeVariable for: public class ISO8601DateFormatter {
  private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
  private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
  private static final String UTC_PLUS="+";
  private static final String UTC_MINUS="-";
  public Date toDate(  String iso8601string) throws ParseException {
    iso8601string=iso8601string.trim();
    if (iso8601string.toUpperCase().indexOf("Z") > 0) {
      iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
    }
 else     if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
    }
 else     if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
    }
    Date date=null;
    if (iso8601string.contains(":"))     date=DATE_FORMAT_1.parse(iso8601string);
 else {
      date=DATE_FORMAT_2.parse(iso8601string);
    }
    return date;
  }
  public String toISO8601String(  Date date){
    return DATE_FORMAT_1.format(date);
  }
  private String replaceColon(  String sourceStr,  int offsetIndex){
    if (sourceStr.substring(offsetIndex).contains(":"))     return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
    return sourceStr;
  }
  private String appendZeros(  String sourceStr,  int offsetIndex,  String offsetChar){
    if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)     return sourceStr + "00";
    return sourceStr;
  }
}

Did not find solution for node: ISO8601DateFormatter with type Type2
For node: DateFormat expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
For node: DateFormat expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
Cannot find matching typeVariable for: DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ")
For node: DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ") expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
For node: DATE_FORMAT_1 expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
For node: new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ") expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: SimpleDateFormat expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: SimpleDateFormat expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: "yyyy-MM-dd'T'HH:mm:ssZ" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: DateFormat expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
For node: DateFormat expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
Cannot find matching typeVariable for: DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ")
For node: DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ") expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
For node: DATE_FORMAT_2 expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
For node: new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ") expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: SimpleDateFormat expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: SimpleDateFormat expected fqn: java.text.SimpleDateFormat with type: Type8 got: java.text.SimpleDateFormat
For node: "yyyy-MM-dd'T'HHmmssZ" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: UTC_PLUS="+"
For node: UTC_PLUS="+" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: UTC_PLUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: "+" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: UTC_MINUS="-"
For node: UTC_MINUS="-" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: UTC_MINUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: "-" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
Cannot find matching typeVariable for: toDate
Cannot find matching typeVariable for: public Date toDate(String iso8601string) throws ParseException {
  iso8601string=iso8601string.trim();
  if (iso8601string.toUpperCase().indexOf("Z") > 0) {
    iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
  }
 else   if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
    iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
    iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
  }
 else   if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
    iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
    iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
  }
  Date date=null;
  if (iso8601string.contains(":"))   date=DATE_FORMAT_1.parse(iso8601string);
 else {
    date=DATE_FORMAT_2.parse(iso8601string);
  }
  return date;
}

Cannot find matching typeVariable for: public class ISO8601DateFormatter {
  private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
  private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
  private static final String UTC_PLUS="+";
  private static final String UTC_MINUS="-";
  public Date toDate(  String iso8601string) throws ParseException {
    iso8601string=iso8601string.trim();
    if (iso8601string.toUpperCase().indexOf("Z") > 0) {
      iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
    }
 else     if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
    }
 else     if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
    }
    Date date=null;
    if (iso8601string.contains(":"))     date=DATE_FORMAT_1.parse(iso8601string);
 else {
      date=DATE_FORMAT_2.parse(iso8601string);
    }
    return date;
  }
  public String toISO8601String(  Date date){
    return DATE_FORMAT_1.format(date);
  }
  private String replaceColon(  String sourceStr,  int offsetIndex){
    if (sourceStr.substring(offsetIndex).contains(":"))     return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
    return sourceStr;
  }
  private String appendZeros(  String sourceStr,  int offsetIndex,  String offsetChar){
    if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)     return sourceStr + "00";
    return sourceStr;
  }
}

Cannot find matching typeVariable for: /** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.text.ParseException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
/** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: String iso8601string
For node: String iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: ParseException expected fqn: java.text.ParseException with type: Type27 got: java.text.ParseException
For node: ParseException expected fqn: java.text.ParseException with type: Type27 got: java.text.ParseException
For node: iso8601string=iso8601string.trim() expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string.trim() expected fqn: java.lang.String with type: Type53 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: trim
For node: trim expected fqn: java.lang.String with type: Type53 got: java.lang.String
For node: iso8601string.toUpperCase().indexOf("Z") > 0 expected fqn: boolean with type: Type60 got: boolean
For node: iso8601string.toUpperCase().indexOf("Z") expected fqn: int with type: Type57 got: byte
Did not find solution for node: iso8601string.toUpperCase() with type Type55
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: toUpperCase
Did not find solution for node: toUpperCase with type Type55
Cannot find matching typeVariable for: indexOf
For node: indexOf expected fqn: int with type: Type57 got: byte
For node: "Z" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: 0 expected fqn: int with type: Type16 got: byte
For node: iso8601string=iso8601string.toUpperCase().replace("Z","+0000") expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string.toUpperCase().replace("Z","+0000") expected fqn: java.lang.String with type: Type61 got: java.lang.String
Did not find solution for node: iso8601string.toUpperCase() with type Type56
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: toUpperCase
Did not find solution for node: toUpperCase with type Type56
Cannot find matching typeVariable for: replace
For node: replace expected fqn: java.lang.String with type: Type61 got: java.lang.String
For node: "Z" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: "+0000" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: ((iso8601string.indexOf(UTC_PLUS)) > 0) expected fqn: boolean with type: Type60 got: boolean
For node: (iso8601string.indexOf(UTC_PLUS)) > 0 expected fqn: boolean with type: Type60 got: boolean
Did not find solution for node: (iso8601string.indexOf(UTC_PLUS)) with type Type65
Did not find solution for node: iso8601string.indexOf(UTC_PLUS) with type Type65
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: indexOf
Did not find solution for node: indexOf with type Type65
For node: UTC_PLUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: 0 expected fqn: int with type: Type16 got: byte
For node: iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS)) expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS)) expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: replaceColon
For node: replaceColon expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: iso8601string
For node: iso8601string expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: iso8601string.indexOf(UTC_PLUS) expected fqn: int with type: Type67 got: int
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: indexOf
For node: indexOf expected fqn: int with type: Type67 got: int
For node: UTC_PLUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS) expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS) expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: appendZeros
For node: appendZeros expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: iso8601string
For node: iso8601string expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: iso8601string.indexOf(UTC_PLUS) expected fqn: int with type: Type67 got: int
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: indexOf
For node: indexOf expected fqn: int with type: Type67 got: int
For node: UTC_PLUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: UTC_PLUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: ((iso8601string.indexOf(UTC_MINUS)) > 0) expected fqn: boolean with type: Type60 got: boolean
For node: (iso8601string.indexOf(UTC_MINUS)) > 0 expected fqn: boolean with type: Type60 got: boolean
For node: (iso8601string.indexOf(UTC_MINUS)) expected fqn: int with type: Type67 got: int
For node: iso8601string.indexOf(UTC_MINUS) expected fqn: int with type: Type67 got: int
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: indexOf
For node: indexOf expected fqn: int with type: Type67 got: int
For node: UTC_MINUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: 0 expected fqn: int with type: Type16 got: byte
For node: iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS)) expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS)) expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: replaceColon
For node: replaceColon expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: iso8601string
For node: iso8601string expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: iso8601string.indexOf(UTC_MINUS) expected fqn: int with type: Type67 got: int
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: indexOf
For node: indexOf expected fqn: int with type: Type67 got: int
For node: UTC_MINUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS) expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS) expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: appendZeros
For node: appendZeros expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: iso8601string
For node: iso8601string expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: iso8601string.indexOf(UTC_MINUS) expected fqn: int with type: Type67 got: int
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: indexOf
For node: indexOf expected fqn: int with type: Type67 got: int
For node: UTC_MINUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: UTC_MINUS expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
Cannot find matching typeVariable for: date=null
For node: date=null expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: null expected fqn: null with type: Type68 got: java.util.Date
For node: iso8601string.contains(":") expected fqn: boolean with type: Type69 got: boolean
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: contains
For node: contains expected fqn: boolean with type: Type69 got: boolean
For node: ":" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: date=DATE_FORMAT_1.parse(iso8601string) expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: DATE_FORMAT_1.parse(iso8601string) expected fqn: java.util.Date with type: Type72 got: java.util.Date
For node: DATE_FORMAT_1 expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
Cannot find matching typeVariable for: parse
For node: parse expected fqn: java.util.Date with type: Type72 got: java.util.Date
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: date=DATE_FORMAT_2.parse(iso8601string) expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: DATE_FORMAT_2.parse(iso8601string) expected fqn: java.util.Date with type: Type74 got: java.util.Date
For node: DATE_FORMAT_2 expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
Cannot find matching typeVariable for: parse
For node: parse expected fqn: java.util.Date with type: Type74 got: java.util.Date
For node: iso8601string expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: toISO8601String
Cannot find matching typeVariable for: public String toISO8601String(Date date){
  return DATE_FORMAT_1.format(date);
}

Cannot find matching typeVariable for: public class ISO8601DateFormatter {
  private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
  private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
  private static final String UTC_PLUS="+";
  private static final String UTC_MINUS="-";
  public Date toDate(  String iso8601string) throws ParseException {
    iso8601string=iso8601string.trim();
    if (iso8601string.toUpperCase().indexOf("Z") > 0) {
      iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
    }
 else     if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
    }
 else     if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
    }
    Date date=null;
    if (iso8601string.contains(":"))     date=DATE_FORMAT_1.parse(iso8601string);
 else {
      date=DATE_FORMAT_2.parse(iso8601string);
    }
    return date;
  }
  public String toISO8601String(  Date date){
    return DATE_FORMAT_1.format(date);
  }
  private String replaceColon(  String sourceStr,  int offsetIndex){
    if (sourceStr.substring(offsetIndex).contains(":"))     return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
    return sourceStr;
  }
  private String appendZeros(  String sourceStr,  int offsetIndex,  String offsetChar){
    if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)     return sourceStr + "00";
    return sourceStr;
  }
}

Cannot find matching typeVariable for: /** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.text.ParseException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
/** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: Date date
For node: Date date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: Date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: DATE_FORMAT_1.format(date) expected fqn: java.lang.String with type: Type75 got: java.lang.String
For node: DATE_FORMAT_1 expected fqn: java.text.DateFormat with type: Type52 got: java.text.DateFormat
Cannot find matching typeVariable for: format
For node: format expected fqn: java.lang.String with type: Type75 got: java.lang.String
For node: date expected fqn: java.util.Date with type: Type5 got: java.util.Date
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: replaceColon
Cannot find matching typeVariable for: private String replaceColon(String sourceStr,int offsetIndex){
  if (sourceStr.substring(offsetIndex).contains(":"))   return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
  return sourceStr;
}

Cannot find matching typeVariable for: public class ISO8601DateFormatter {
  private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
  private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
  private static final String UTC_PLUS="+";
  private static final String UTC_MINUS="-";
  public Date toDate(  String iso8601string) throws ParseException {
    iso8601string=iso8601string.trim();
    if (iso8601string.toUpperCase().indexOf("Z") > 0) {
      iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
    }
 else     if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
    }
 else     if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
    }
    Date date=null;
    if (iso8601string.contains(":"))     date=DATE_FORMAT_1.parse(iso8601string);
 else {
      date=DATE_FORMAT_2.parse(iso8601string);
    }
    return date;
  }
  public String toISO8601String(  Date date){
    return DATE_FORMAT_1.format(date);
  }
  private String replaceColon(  String sourceStr,  int offsetIndex){
    if (sourceStr.substring(offsetIndex).contains(":"))     return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
    return sourceStr;
  }
  private String appendZeros(  String sourceStr,  int offsetIndex,  String offsetChar){
    if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)     return sourceStr + "00";
    return sourceStr;
  }
}

Cannot find matching typeVariable for: /** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.text.ParseException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
/** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: String sourceStr
For node: String sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: int offsetIndex
For node: int offsetIndex expected fqn: int with type: Type78 got: int
For node: int expected fqn: int with type: Type78 got: int
For node: offsetIndex expected fqn: int with type: Type78 got: int
Did not find solution for node: sourceStr.substring(offsetIndex).contains(":") with type Type82
For node: sourceStr.substring(offsetIndex) expected fqn: java.lang.String with type: Type79 got: java.lang.String
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: substring
For node: substring expected fqn: java.lang.String with type: Type79 got: java.lang.String
For node: offsetIndex expected fqn: int with type: Type78 got: int
Cannot find matching typeVariable for: contains
Did not find solution for node: contains with type Type82
For node: ":" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","") expected fqn: java.lang.String with type: Type85 got: java.lang.String
For node: sourceStr.substring(0,offsetIndex) expected fqn: java.lang.String with type: Type85 got: java.lang.String
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: substring
For node: substring expected fqn: java.lang.String with type: Type85 got: java.lang.String
For node: 0 expected fqn: int with type: Type16 got: byte
For node: offsetIndex expected fqn: int with type: Type78 got: int
For node: sourceStr.substring(offsetIndex).replace(":","") expected fqn: java.lang.String with type: Type89 got: java.lang.String
For node: sourceStr.substring(offsetIndex) expected fqn: java.lang.String with type: Type81 got: java.lang.String
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: substring
For node: substring expected fqn: java.lang.String with type: Type81 got: java.lang.String
For node: offsetIndex expected fqn: int with type: Type78 got: int
Cannot find matching typeVariable for: replace
For node: replace expected fqn: java.lang.String with type: Type89 got: java.lang.String
For node: ":" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: "" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type3 got: java.lang.String
Cannot find matching typeVariable for: appendZeros
Cannot find matching typeVariable for: private String appendZeros(String sourceStr,int offsetIndex,String offsetChar){
  if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)   return sourceStr + "00";
  return sourceStr;
}

Cannot find matching typeVariable for: public class ISO8601DateFormatter {
  private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
  private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
  private static final String UTC_PLUS="+";
  private static final String UTC_MINUS="-";
  public Date toDate(  String iso8601string) throws ParseException {
    iso8601string=iso8601string.trim();
    if (iso8601string.toUpperCase().indexOf("Z") > 0) {
      iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
    }
 else     if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
    }
 else     if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
      iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
      iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
    }
    Date date=null;
    if (iso8601string.contains(":"))     date=DATE_FORMAT_1.parse(iso8601string);
 else {
      date=DATE_FORMAT_2.parse(iso8601string);
    }
    return date;
  }
  public String toISO8601String(  Date date){
    return DATE_FORMAT_1.format(date);
  }
  private String replaceColon(  String sourceStr,  int offsetIndex){
    if (sourceStr.substring(offsetIndex).contains(":"))     return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
    return sourceStr;
  }
  private String appendZeros(  String sourceStr,  int offsetIndex,  String offsetChar){
    if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)     return sourceStr + "00";
    return sourceStr;
  }
}

Cannot find matching typeVariable for: /** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: package Class_;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Date;
import java.text.ParseException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
/** 
 * Helper class for handling a most common subset of ISO 8601 strings (in the following format: "2008-03-01T13:00:00+01:00"). It supports parsing the "Z" timezone, but many other less-used features are missing.
 */
public final class Class_12 {
  /** 
 * Transform Calendar to ISO 8601 string. 
 */
  public static String fromCalendar(  final Calendar calendar){
    Date date=calendar.getTime();
    String formatted=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
    return formatted.substring(0,22) + ":" + formatted.substring(22);
  }
  /** 
 * Get current date and time formatted as ISO 8601 string. 
 */
  public static String now(){
    return fromCalendar(GregorianCalendar.getInstance());
  }
  /** 
 * Transform ISO 8601 string to Calendar. 
 */
  public static Calendar toCalendar(  final String iso8601string) throws ParseException {
    Calendar calendar=GregorianCalendar.getInstance();
    String s=iso8601string.replace("Z","+00:00");
    try {
      s=s.substring(0,22) + s.substring(23);
    }
 catch (    IndexOutOfBoundsException e) {
      throw new ParseException("Invalid length",0);
    }
    Date date=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(s);
    calendar.setTime(date);
    return calendar;
  }
public class ISO8601DateFormatter {
    private final DateFormat DATE_FORMAT_1=new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ");
    private final DateFormat DATE_FORMAT_2=new SimpleDateFormat("yyyy-MM-dd'T'HHmmssZ");
    private static final String UTC_PLUS="+";
    private static final String UTC_MINUS="-";
    public Date toDate(    String iso8601string) throws ParseException {
      iso8601string=iso8601string.trim();
      if (iso8601string.toUpperCase().indexOf("Z") > 0) {
        iso8601string=iso8601string.toUpperCase().replace("Z","+0000");
      }
 else       if (((iso8601string.indexOf(UTC_PLUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_PLUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_PLUS),UTC_PLUS);
      }
 else       if (((iso8601string.indexOf(UTC_MINUS)) > 0)) {
        iso8601string=replaceColon(iso8601string,iso8601string.indexOf(UTC_MINUS));
        iso8601string=appendZeros(iso8601string,iso8601string.indexOf(UTC_MINUS),UTC_MINUS);
      }
      Date date=null;
      if (iso8601string.contains(":"))       date=DATE_FORMAT_1.parse(iso8601string);
 else {
        date=DATE_FORMAT_2.parse(iso8601string);
      }
      return date;
    }
    public String toISO8601String(    Date date){
      return DATE_FORMAT_1.format(date);
    }
    private String replaceColon(    String sourceStr,    int offsetIndex){
      if (sourceStr.substring(offsetIndex).contains(":"))       return sourceStr.substring(0,offsetIndex) + sourceStr.substring(offsetIndex).replace(":","");
      return sourceStr;
    }
    private String appendZeros(    String sourceStr,    int offsetIndex,    String offsetChar){
      if ((sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2)       return sourceStr + "00";
      return sourceStr;
    }
  }
}

Cannot find matching typeVariable for: String sourceStr
For node: String sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: int offsetIndex
For node: int offsetIndex expected fqn: int with type: Type78 got: int
For node: int expected fqn: int with type: Type78 got: int
For node: offsetIndex expected fqn: int with type: Type78 got: int
Cannot find matching typeVariable for: String offsetChar
For node: String offsetChar expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: String expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: offsetChar expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: (sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) <= 2 expected fqn: boolean with type: Type60 got: boolean
Did not find solution for node: (sourceStr.length() - 1) - sourceStr.indexOf(offsetChar,offsetIndex) with type Type93
Did not find solution for node: (sourceStr.length() - 1) with type Type93
Did not find solution for node: sourceStr.length() - 1 with type Type93
Did not find solution for node: sourceStr.length() with type Type93
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: length
Did not find solution for node: length with type Type93
For node: 1 expected fqn: int with type: Type16 got: byte
Did not find solution for node: sourceStr.indexOf(offsetChar,offsetIndex) with type Type95
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
Cannot find matching typeVariable for: indexOf
Did not find solution for node: indexOf with type Type95
For node: offsetChar expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: offsetIndex expected fqn: int with type: Type78 got: int
For node: 2 expected fqn: int with type: Type16 got: byte
For node: sourceStr + "00" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: "00" expected fqn: java.lang.String with type: Type9 got: java.lang.String
For node: sourceStr expected fqn: java.lang.String with type: Type9 got: java.lang.String
{Checked=308, Analyzed=291, Unsolved=17, Incorrect=16, Correct=275}
=SimpleName: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
boolean=InfixExpression: {Checked=4, Analyzed=4, Unsolved=0, Incorrect=0, Correct=4}
boolean=MethodInvocation: {Checked=2, Analyzed=1, Unsolved=1, Incorrect=0, Correct=1}
boolean=ParenthesizedExpression: {Checked=2, Analyzed=2, Unsolved=0, Incorrect=0, Correct=2}
boolean=SimpleName: {Checked=2, Analyzed=1, Unsolved=1, Incorrect=0, Correct=1}
int=InfixExpression: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
int=MethodInvocation: {Checked=9, Analyzed=6, Unsolved=3, Incorrect=1, Correct=5}
int=NumberLiteral: {Checked=13, Analyzed=13, Unsolved=0, Incorrect=13, Correct=0}
int=ParenthesizedExpression: {Checked=3, Analyzed=1, Unsolved=2, Incorrect=0, Correct=1}
int=PrimitiveType: {Checked=2, Analyzed=2, Unsolved=0, Incorrect=0, Correct=2}
int=SimpleName: {Checked=15, Analyzed=12, Unsolved=3, Incorrect=1, Correct=11}
int=SingleVariableDeclaration: {Checked=2, Analyzed=2, Unsolved=0, Incorrect=0, Correct=2}
java=Assignment: {Checked=9, Analyzed=9, Unsolved=0, Incorrect=0, Correct=9}
java=ClassInstanceCreation: {Checked=5, Analyzed=5, Unsolved=0, Incorrect=0, Correct=5}
java=InfixExpression: {Checked=4, Analyzed=4, Unsolved=0, Incorrect=0, Correct=4}
java=MethodInvocation: {Checked=26, Analyzed=24, Unsolved=2, Incorrect=0, Correct=24}
java=SimpleName: {Checked=136, Analyzed=134, Unsolved=2, Incorrect=0, Correct=134}
java=SimpleType: {Checked=32, Analyzed=32, Unsolved=0, Incorrect=0, Correct=32}
java=SingleVariableDeclaration: {Checked=8, Analyzed=8, Unsolved=0, Incorrect=0, Correct=8}
java=StringLiteral: {Checked=18, Analyzed=18, Unsolved=0, Incorrect=0, Correct=18}
java=VariableDeclarationFragment: {Checked=10, Analyzed=10, Unsolved=0, Incorrect=0, Correct=10}
null=NullLiteral: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=1, Correct=0}
void=MethodInvocation: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=0, Correct=1}
void=SimpleName: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=0, Correct=1}
Total stats
{Checked=308, Analyzed=291, Unsolved=17, Incorrect=16, Correct=275}
=SimpleName: {Checked=1, Analyzed=0, Unsolved=1, Incorrect=0, Correct=0}
boolean=InfixExpression: {Checked=4, Analyzed=4, Unsolved=0, Incorrect=0, Correct=4}
boolean=MethodInvocation: {Checked=2, Analyzed=1, Unsolved=1, Incorrect=0, Correct=1}
boolean=ParenthesizedExpression: {Checked=2, Analyzed=2, Unsolved=0, Incorrect=0, Correct=2}
boolean=SimpleName: {Checked=2, Analyzed=1, Unsolved=1, Incorrect=0, Correct=1}
int=InfixExpression: {Checked=2, Analyzed=0, Unsolved=2, Incorrect=0, Correct=0}
int=MethodInvocation: {Checked=9, Analyzed=6, Unsolved=3, Incorrect=1, Correct=5}
int=NumberLiteral: {Checked=13, Analyzed=13, Unsolved=0, Incorrect=13, Correct=0}
int=ParenthesizedExpression: {Checked=3, Analyzed=1, Unsolved=2, Incorrect=0, Correct=1}
int=PrimitiveType: {Checked=2, Analyzed=2, Unsolved=0, Incorrect=0, Correct=2}
int=SimpleName: {Checked=15, Analyzed=12, Unsolved=3, Incorrect=1, Correct=11}
int=SingleVariableDeclaration: {Checked=2, Analyzed=2, Unsolved=0, Incorrect=0, Correct=2}
java=Assignment: {Checked=9, Analyzed=9, Unsolved=0, Incorrect=0, Correct=9}
java=ClassInstanceCreation: {Checked=5, Analyzed=5, Unsolved=0, Incorrect=0, Correct=5}
java=InfixExpression: {Checked=4, Analyzed=4, Unsolved=0, Incorrect=0, Correct=4}
java=MethodInvocation: {Checked=26, Analyzed=24, Unsolved=2, Incorrect=0, Correct=24}
java=SimpleName: {Checked=136, Analyzed=134, Unsolved=2, Incorrect=0, Correct=134}
java=SimpleType: {Checked=32, Analyzed=32, Unsolved=0, Incorrect=0, Correct=32}
java=SingleVariableDeclaration: {Checked=8, Analyzed=8, Unsolved=0, Incorrect=0, Correct=8}
java=StringLiteral: {Checked=18, Analyzed=18, Unsolved=0, Incorrect=0, Correct=18}
java=VariableDeclarationFragment: {Checked=10, Analyzed=10, Unsolved=0, Incorrect=0, Correct=10}
null=NullLiteral: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=1, Correct=0}
void=MethodInvocation: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=0, Correct=1}
void=SimpleName: {Checked=1, Analyzed=1, Unsolved=0, Incorrect=0, Correct=1}
,SimpleName,0,1,0,0,1
boolean,InfixExpression,4,4,4,0,0
boolean,MethodInvocation,1,2,1,0,1
boolean,ParenthesizedExpression,2,2,2,0,0
boolean,SimpleName,1,2,1,0,1
int,InfixExpression,0,2,0,0,2
int,MethodInvocation,6,9,5,1,3
int,NumberLiteral,13,13,0,13,0
int,ParenthesizedExpression,1,3,1,0,2
int,PrimitiveType,2,2,2,0,0
int,SimpleName,12,15,11,1,3
int,SingleVariableDeclaration,2,2,2,0,0
java,Assignment,9,9,9,0,0
java,ClassInstanceCreation,5,5,5,0,0
java,InfixExpression,4,4,4,0,0
java,MethodInvocation,24,26,24,0,2
java,SimpleName,134,136,134,0,2
java,SimpleType,32,32,32,0,0
java,SingleVariableDeclaration,8,8,8,0,0
java,StringLiteral,18,18,18,0,0
java,VariableDeclarationFragment,10,10,10,0,0
null,NullLiteral,1,1,0,1,0
void,MethodInvocation,1,1,1,0,0
void,SimpleName,1,1,1,0,0
