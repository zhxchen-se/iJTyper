{"status":2,"problems":[{"fileName":"Class_16.java","startLocation":921,"endLocation":939,"lineNumber":26,"column":27,"message":"Type safety: The expression of type Class needs unchecked conversion to conform to Class<? extends Preferences>","problemId":16777748,"problemSeverity":"WARNING"}],"originalContent":"/*\nDate: 1/19/17\nURL: http://stackoverflow.com/questions/62289/read-write-to-windows-registry-using-java\n*/\npackage Class_;\n\n\npublic class Class_16 {\n\tpublic static final int HKEY_CURRENT_USER = 0x80000001;\n\tpublic static final int HKEY_LOCAL_MACHINE = 0x80000002;\n\tpublic static final int REG_SUCCESS = 0;\n\tpublic static final int REG_NOTFOUND = 2;\n\tpublic static final int REG_ACCESSDENIED = 5;\n\n\tprivate static final int KEY_ALL_ACCESS = 0xf003f;\n\tprivate static final int KEY_READ = 0x20019;\n\tprivate static final Preferences userRoot = Preferences.userRoot();\n\tprivate static final Preferences systemRoot = Preferences.systemRoot();\n\tprivate static final Class<? extends Preferences> userClass = userRoot.getClass();\n\tprivate static final Method regOpenKey;\n\tprivate static final Method regCloseKey;\n\tprivate static final Method regQueryValueEx;\n\tprivate static final Method regEnumValue;\n\tprivate static final Method regQueryInfoKey;\n\tprivate static final Method regEnumKeyEx;\n\tprivate static final Method regCreateKeyEx;\n\tprivate static final Method regSetValueEx;\n\tprivate static final Method regDeleteKey;\n\tprivate static final Method regDeleteValue;\n\n\tstatic {\n\t\ttry {\n\t\t\tregOpenKey = userClass.getDeclaredMethod(\"WindowsRegOpenKey\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class, int.class });\n\t\t\tregOpenKey.setAccessible(true);\n\t\t\tregCloseKey = userClass.getDeclaredMethod(\"WindowsRegCloseKey\", new Class[] { int.class });\n\t\t\tregCloseKey.setAccessible(true);\n\t\t\tregQueryValueEx = userClass.getDeclaredMethod(\"WindowsRegQueryValueEx\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class });\n\t\t\tregQueryValueEx.setAccessible(true);\n\t\t\tregEnumValue = userClass.getDeclaredMethod(\"WindowsRegEnumValue\",\n\t\t\t\t\tnew Class[] { int.class, int.class, int.class });\n\t\t\tregEnumValue.setAccessible(true);\n\t\t\tregQueryInfoKey = userClass.getDeclaredMethod(\"WindowsRegQueryInfoKey1\", new Class[] { int.class });\n\t\t\tregQueryInfoKey.setAccessible(true);\n\t\t\tregEnumKeyEx = userClass.getDeclaredMethod(\"WindowsRegEnumKeyEx\",\n\t\t\t\t\tnew Class[] { int.class, int.class, int.class });\n\t\t\tregEnumKeyEx.setAccessible(true);\n\t\t\tregCreateKeyEx = userClass.getDeclaredMethod(\"WindowsRegCreateKeyEx\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class });\n\t\t\tregCreateKeyEx.setAccessible(true);\n\t\t\tregSetValueEx = userClass.getDeclaredMethod(\"WindowsRegSetValueEx\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class, byte[].class });\n\t\t\tregSetValueEx.setAccessible(true);\n\t\t\tregDeleteValue = userClass.getDeclaredMethod(\"WindowsRegDeleteValue\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class });\n\t\t\tregDeleteValue.setAccessible(true);\n\t\t\tregDeleteKey = userClass.getDeclaredMethod(\"WindowsRegDeleteKey\", new Class[] { int.class, byte[].class });\n\t\t\tregDeleteKey.setAccessible(true);\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprivate Class_16() {\n\t}\n\n\t/**\n\t * Read a value from key and value name\n\t * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n\t * @param key\n\t * @param valueName\n\t * @return the value\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static String readString(int hkey, String key, String valueName)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\treturn readString(systemRoot, hkey, key, valueName);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\treturn readString(userRoot, hkey, key, valueName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t}\n\n\t/**\n\t * Read value(s) and value name(s) form given key \n\t * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n\t * @param key\n\t * @return the value name(s) plus the value(s)\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static Map<String, String> readStringValues(int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\treturn readStringValues(systemRoot, hkey, key);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\treturn readStringValues(userRoot, hkey, key);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t}\n\n\t/**\n\t * Read the value name(s) from a given key\n\t * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n\t * @param key\n\t * @return the value name(s)\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static List<String> readStringSubKeys(int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\treturn readStringSubKeys(systemRoot, hkey, key);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\treturn readStringSubKeys(userRoot, hkey, key);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t}\n\n\t/**\n\t * Create a key\n\t * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n\t * @param key\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static void createKey(int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] ret;\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\tret = createKey(systemRoot, hkey, key);\n\t\t\tregCloseKey.invoke(systemRoot, new Object[] { new Integer(ret[0]) });\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\tret = createKey(userRoot, hkey, key);\n\t\t\tregCloseKey.invoke(userRoot, new Object[] { new Integer(ret[0]) });\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t\tif (ret[1] != REG_SUCCESS) {\n\t\t\tthrow new IllegalArgumentException(\"rc=\" + ret[1] + \"  key=\" + key);\n\t\t}\n\t}\n\n\t/**\n\t * Write a value in a given key/value name\n\t * @param hkey\n\t * @param key\n\t * @param valueName\n\t * @param value\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static void writeStringValue(int hkey, String key, String valueName, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\twriteStringValue(systemRoot, hkey, key, valueName, value);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\twriteStringValue(userRoot, hkey, key, valueName, value);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t}\n\n\t/**\n\t * Delete a given key\n\t * @param hkey\n\t * @param key\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static void deleteKey(int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint rc = -1;\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\trc = deleteKey(systemRoot, hkey, key);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\trc = deleteKey(userRoot, hkey, key);\n\t\t}\n\t\tif (rc != REG_SUCCESS) {\n\t\t\tthrow new IllegalArgumentException(\"rc=\" + rc + \"  key=\" + key);\n\t\t}\n\t}\n\n\t/**\n\t * delete a value from a given key/value name\n\t * @param hkey\n\t * @param key\n\t * @param value\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static void deleteValue(int hkey, String key, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint rc = -1;\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\trc = deleteValue(systemRoot, hkey, key, value);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\trc = deleteValue(userRoot, hkey, key, value);\n\t\t}\n\t\tif (rc != REG_SUCCESS) {\n\t\t\tthrow new IllegalArgumentException(\"rc=\" + rc + \"  key=\" + key + \"  value=\" + value);\n\t\t}\n\t}\n\n\t// =====================\n\n\tprivate static int deleteValue(Preferences root, int hkey, String key, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) });\n\t\tif (handles[1] != REG_SUCCESS) {\n\t\t\treturn handles[1]; // can be REG_NOTFOUND, REG_ACCESSDENIED\n\t\t}\n\t\tint rc = ((Integer) regDeleteValue.invoke(root, new Object[] { new Integer(handles[0]), toCstr(value) }))\n\t\t\t\t.intValue();\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t\treturn rc;\n\t}\n\n\tprivate static int deleteKey(Preferences root, int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint rc = ((Integer) regDeleteKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key) })).intValue();\n\t\treturn rc; // can REG_NOTFOUND, REG_ACCESSDENIED, REG_SUCCESS\n\t}\n\n\tprivate static String readString(Preferences root, int hkey, String key, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ) });\n\t\tif (handles[1] != REG_SUCCESS) {\n\t\t\treturn null;\n\t\t}\n\t\tbyte[] valb = (byte[]) regQueryValueEx.invoke(root, new Object[] { new Integer(handles[0]), toCstr(value) });\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t\treturn (valb != null ? new String(valb).trim() : null);\n\t}\n\n\tprivate static Map<String, String> readStringValues(Preferences root, int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tHashMap<String, String> results = new HashMap<String, String>();\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ) });\n\t\tif (handles[1] != REG_SUCCESS) {\n\t\t\treturn null;\n\t\t}\n\t\tint[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\n\t\tint count = info[0]; // count  \n\t\tint maxlen = info[3]; // value length max\n\t\tfor (int index = 0; index < count; index++) {\n\t\t\tbyte[] name = (byte[]) regEnumValue.invoke(root,\n\t\t\t\t\tnew Object[] { new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1) });\n\t\t\tString value = readString(hkey, key, new String(name));\n\t\t\tresults.put(new String(name).trim(), value);\n\t\t}\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t\treturn results;\n\t}\n\n\tprivate static List<String> readStringSubKeys(Preferences root, int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tList<String> results = new ArrayList<String>();\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ) });\n\t\tif (handles[1] != REG_SUCCESS) {\n\t\t\treturn null;\n\t\t}\n\t\tint[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\n\t\tint count = info[0]; // Fix: info[2] was being used here with wrong results. Suggested by davenpcj, confirmed by Petrucio\n\t\tint maxlen = info[3]; // value length max\n\t\tfor (int index = 0; index < count; index++) {\n\t\t\tbyte[] name = (byte[]) regEnumKeyEx.invoke(root,\n\t\t\t\t\tnew Object[] { new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1) });\n\t\t\tresults.add(new String(name).trim());\n\t\t}\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t\treturn results;\n\t}\n\n\tprivate static int[] createKey(Preferences root, int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\treturn (int[]) regCreateKeyEx.invoke(root, new Object[] { new Integer(hkey), toCstr(key) });\n\t}\n\n\tprivate static void writeStringValue(Preferences root, int hkey, String key, String valueName, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) });\n\n\t\tregSetValueEx.invoke(root, new Object[] { new Integer(handles[0]), toCstr(valueName), toCstr(value) });\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t}\n\n\t// utility\n\tprivate static byte[] toCstr(String str) {\n\t\tbyte[] result = new byte[str.length() + 1];\n\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tresult[i] = (byte) str.charAt(i);\n\t\t}\n\t\tresult[str.length()] = 0;\n\t\treturn result;\n\t}\n}","updatedContent":"/*\nDate: 1/19/17\nURL: http://stackoverflow.com/questions/62289/read-write-to-windows-registry-using-java\n*/\npackage Class_;\n\nimport java.util.Map;\nimport java.util.List;\nimport java.util.HashMap;\nimport java.util.prefs.Preferences;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\n\npublic class Class_16 {\n\tpublic static final int HKEY_CURRENT_USER = 0x80000001;\n\tpublic static final int HKEY_LOCAL_MACHINE = 0x80000002;\n\tpublic static final int REG_SUCCESS = 0;\n\tpublic static final int REG_NOTFOUND = 2;\n\tpublic static final int REG_ACCESSDENIED = 5;\n\n\tprivate static final int KEY_ALL_ACCESS = 0xf003f;\n\tprivate static final int KEY_READ = 0x20019;\n\tprivate static final Preferences userRoot = Preferences.userRoot();\n\tprivate static final Preferences systemRoot = Preferences.systemRoot();\n\tprivate static final Class<? extends Preferences> userClass = userRoot.getClass();\n\tprivate static final Method regOpenKey;\n\tprivate static final Method regCloseKey;\n\tprivate static final Method regQueryValueEx;\n\tprivate static final Method regEnumValue;\n\tprivate static final Method regQueryInfoKey;\n\tprivate static final Method regEnumKeyEx;\n\tprivate static final Method regCreateKeyEx;\n\tprivate static final Method regSetValueEx;\n\tprivate static final Method regDeleteKey;\n\tprivate static final Method regDeleteValue;\n\n\tstatic {\n\t\ttry {\n\t\t\tregOpenKey = userClass.getDeclaredMethod(\"WindowsRegOpenKey\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class, int.class });\n\t\t\tregOpenKey.setAccessible(true);\n\t\t\tregCloseKey = userClass.getDeclaredMethod(\"WindowsRegCloseKey\", new Class[] { int.class });\n\t\t\tregCloseKey.setAccessible(true);\n\t\t\tregQueryValueEx = userClass.getDeclaredMethod(\"WindowsRegQueryValueEx\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class });\n\t\t\tregQueryValueEx.setAccessible(true);\n\t\t\tregEnumValue = userClass.getDeclaredMethod(\"WindowsRegEnumValue\",\n\t\t\t\t\tnew Class[] { int.class, int.class, int.class });\n\t\t\tregEnumValue.setAccessible(true);\n\t\t\tregQueryInfoKey = userClass.getDeclaredMethod(\"WindowsRegQueryInfoKey1\", new Class[] { int.class });\n\t\t\tregQueryInfoKey.setAccessible(true);\n\t\t\tregEnumKeyEx = userClass.getDeclaredMethod(\"WindowsRegEnumKeyEx\",\n\t\t\t\t\tnew Class[] { int.class, int.class, int.class });\n\t\t\tregEnumKeyEx.setAccessible(true);\n\t\t\tregCreateKeyEx = userClass.getDeclaredMethod(\"WindowsRegCreateKeyEx\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class });\n\t\t\tregCreateKeyEx.setAccessible(true);\n\t\t\tregSetValueEx = userClass.getDeclaredMethod(\"WindowsRegSetValueEx\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class, byte[].class });\n\t\t\tregSetValueEx.setAccessible(true);\n\t\t\tregDeleteValue = userClass.getDeclaredMethod(\"WindowsRegDeleteValue\",\n\t\t\t\t\tnew Class[] { int.class, byte[].class });\n\t\t\tregDeleteValue.setAccessible(true);\n\t\t\tregDeleteKey = userClass.getDeclaredMethod(\"WindowsRegDeleteKey\", new Class[] { int.class, byte[].class });\n\t\t\tregDeleteKey.setAccessible(true);\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprivate Class_16() {\n\t}\n\n\t/**\n\t * Read a value from key and value name\n\t * @param hkey   HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n\t * @param key\n\t * @param valueName\n\t * @return the value\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static String readString(int hkey, String key, String valueName)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\treturn readString(systemRoot, hkey, key, valueName);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\treturn readString(userRoot, hkey, key, valueName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t}\n\n\t/**\n\t * Read value(s) and value name(s) form given key \n\t * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n\t * @param key\n\t * @return the value name(s) plus the value(s)\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static Map<String, String> readStringValues(int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\treturn readStringValues(systemRoot, hkey, key);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\treturn readStringValues(userRoot, hkey, key);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t}\n\n\t/**\n\t * Read the value name(s) from a given key\n\t * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n\t * @param key\n\t * @return the value name(s)\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static List<String> readStringSubKeys(int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\treturn readStringSubKeys(systemRoot, hkey, key);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\treturn readStringSubKeys(userRoot, hkey, key);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t}\n\n\t/**\n\t * Create a key\n\t * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n\t * @param key\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static void createKey(int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] ret;\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\tret = createKey(systemRoot, hkey, key);\n\t\t\tregCloseKey.invoke(systemRoot, new Object[] { new Integer(ret[0]) });\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\tret = createKey(userRoot, hkey, key);\n\t\t\tregCloseKey.invoke(userRoot, new Object[] { new Integer(ret[0]) });\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t\tif (ret[1] != REG_SUCCESS) {\n\t\t\tthrow new IllegalArgumentException(\"rc=\" + ret[1] + \"  key=\" + key);\n\t\t}\n\t}\n\n\t/**\n\t * Write a value in a given key/value name\n\t * @param hkey\n\t * @param key\n\t * @param valueName\n\t * @param value\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static void writeStringValue(int hkey, String key, String valueName, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\twriteStringValue(systemRoot, hkey, key, valueName, value);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\twriteStringValue(userRoot, hkey, key, valueName, value);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"hkey=\" + hkey);\n\t\t}\n\t}\n\n\t/**\n\t * Delete a given key\n\t * @param hkey\n\t * @param key\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static void deleteKey(int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint rc = -1;\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\trc = deleteKey(systemRoot, hkey, key);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\trc = deleteKey(userRoot, hkey, key);\n\t\t}\n\t\tif (rc != REG_SUCCESS) {\n\t\t\tthrow new IllegalArgumentException(\"rc=\" + rc + \"  key=\" + key);\n\t\t}\n\t}\n\n\t/**\n\t * delete a value from a given key/value name\n\t * @param hkey\n\t * @param key\n\t * @param value\n\t * @throws IllegalArgumentException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic static void deleteValue(int hkey, String key, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint rc = -1;\n\t\tif (hkey == HKEY_LOCAL_MACHINE) {\n\t\t\trc = deleteValue(systemRoot, hkey, key, value);\n\t\t} else if (hkey == HKEY_CURRENT_USER) {\n\t\t\trc = deleteValue(userRoot, hkey, key, value);\n\t\t}\n\t\tif (rc != REG_SUCCESS) {\n\t\t\tthrow new IllegalArgumentException(\"rc=\" + rc + \"  key=\" + key + \"  value=\" + value);\n\t\t}\n\t}\n\n\t// =====================\n\n\tprivate static int deleteValue(Preferences root, int hkey, String key, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) });\n\t\tif (handles[1] != REG_SUCCESS) {\n\t\t\treturn handles[1]; // can be REG_NOTFOUND, REG_ACCESSDENIED\n\t\t}\n\t\tint rc = ((Integer) regDeleteValue.invoke(root, new Object[] { new Integer(handles[0]), toCstr(value) }))\n\t\t\t\t.intValue();\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t\treturn rc;\n\t}\n\n\tprivate static int deleteKey(Preferences root, int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint rc = ((Integer) regDeleteKey.invoke(root, new Object[] { new Integer(hkey), toCstr(key) })).intValue();\n\t\treturn rc; // can REG_NOTFOUND, REG_ACCESSDENIED, REG_SUCCESS\n\t}\n\n\tprivate static String readString(Preferences root, int hkey, String key, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ) });\n\t\tif (handles[1] != REG_SUCCESS) {\n\t\t\treturn null;\n\t\t}\n\t\tbyte[] valb = (byte[]) regQueryValueEx.invoke(root, new Object[] { new Integer(handles[0]), toCstr(value) });\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t\treturn (valb != null ? new String(valb).trim() : null);\n\t}\n\n\tprivate static Map<String, String> readStringValues(Preferences root, int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tHashMap<String, String> results = new HashMap<String, String>();\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ) });\n\t\tif (handles[1] != REG_SUCCESS) {\n\t\t\treturn null;\n\t\t}\n\t\tint[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\n\t\tint count = info[0]; // count  \n\t\tint maxlen = info[3]; // value length max\n\t\tfor (int index = 0; index < count; index++) {\n\t\t\tbyte[] name = (byte[]) regEnumValue.invoke(root,\n\t\t\t\t\tnew Object[] { new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1) });\n\t\t\tString value = readString(hkey, key, new String(name));\n\t\t\tresults.put(new String(name).trim(), value);\n\t\t}\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t\treturn results;\n\t}\n\n\tprivate static List<String> readStringSubKeys(Preferences root, int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tList<String> results = new ArrayList<String>();\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_READ) });\n\t\tif (handles[1] != REG_SUCCESS) {\n\t\t\treturn null;\n\t\t}\n\t\tint[] info = (int[]) regQueryInfoKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\n\t\tint count = info[0]; // Fix: info[2] was being used here with wrong results. Suggested by davenpcj, confirmed by Petrucio\n\t\tint maxlen = info[3]; // value length max\n\t\tfor (int index = 0; index < count; index++) {\n\t\t\tbyte[] name = (byte[]) regEnumKeyEx.invoke(root,\n\t\t\t\t\tnew Object[] { new Integer(handles[0]), new Integer(index), new Integer(maxlen + 1) });\n\t\t\tresults.add(new String(name).trim());\n\t\t}\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t\treturn results;\n\t}\n\n\tprivate static int[] createKey(Preferences root, int hkey, String key)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\treturn (int[]) regCreateKeyEx.invoke(root, new Object[] { new Integer(hkey), toCstr(key) });\n\t}\n\n\tprivate static void writeStringValue(Preferences root, int hkey, String key, String valueName, String value)\n\t\t\tthrows IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] handles = (int[]) regOpenKey.invoke(root,\n\t\t\t\tnew Object[] { new Integer(hkey), toCstr(key), new Integer(KEY_ALL_ACCESS) });\n\n\t\tregSetValueEx.invoke(root, new Object[] { new Integer(handles[0]), toCstr(valueName), toCstr(value) });\n\t\tregCloseKey.invoke(root, new Object[] { new Integer(handles[0]) });\n\t}\n\n\t// utility\n\tprivate static byte[] toCstr(String str) {\n\t\tbyte[] result = new byte[str.length() + 1];\n\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tresult[i] = (byte) str.charAt(i);\n\t\t}\n\t\tresult[str.length()] = 0;\n\t\treturn result;\n\t}\n}","usedLibraries":["jar:android-13.jar:1"]}